        -:    0:Source:thttpd.c
        -:    0:Graph:thttpd.gcno
        -:    0:Data:thttpd.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* thttpd.c - tiny/turbo/throttling HTTP server
        -:    2:**
        -:    3:** Copyright © 1995,1998,1999,2000,2001,2015 by
        -:    4:** Jef Poskanzer <jef@mail.acme.com>. All rights reserved.
        -:    5:**
        -:    6:** Redistribution and use in source and binary forms, with or without
        -:    7:** modification, are permitted provided that the following conditions
        -:    8:** are met:
        -:    9:** 1. Redistributions of source code must retain the above copyright
        -:   10:**    notice, this list of conditions and the following disclaimer.
        -:   11:** 2. Redistributions in binary form must reproduce the above copyright
        -:   12:**    notice, this list of conditions and the following disclaimer in the
        -:   13:**    documentation and/or other materials provided with the distribution.
        -:   14:**
        -:   15:** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
        -:   16:** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   17:** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        -:   18:** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        -:   19:** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        -:   20:** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        -:   21:** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:   22:** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        -:   23:** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        -:   24:** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        -:   25:** SUCH DAMAGE.
        -:   26:*/
        -:   27:
        -:   28:
        -:   29:#include "config.h"
        -:   30:#include "version.h"
        -:   31:
        -:   32:#include <sys/param.h>
        -:   33:#include <sys/types.h>
        -:   34:#include <sys/time.h>
        -:   35:#include <sys/stat.h>
        -:   36:#include <sys/wait.h>
        -:   37:#include <sys/uio.h>
        -:   38:
        -:   39:#include <errno.h>
        -:   40:#ifdef HAVE_FCNTL_H
        -:   41:#include <fcntl.h>
        -:   42:#endif
        -:   43:#include <pwd.h>
        -:   44:#ifdef HAVE_GRP_H
        -:   45:#include <grp.h>
        -:   46:#endif
        -:   47:#include <signal.h>
        -:   48:#include <stdio.h>
        -:   49:#include <stdlib.h>
        -:   50:#include <string.h>
        -:   51:#include <syslog.h>
        -:   52:#ifdef TIME_WITH_SYS_TIME
        -:   53:#include <time.h>
        -:   54:#endif
        -:   55:#include <unistd.h>
        -:   56:
        -:   57:#include "fdwatch.h"
        -:   58:#include "libhttpd.h"
        -:   59:#include "mmc.h"
        -:   60:#include "timers.h"
        -:   61:#include "match.h"
        -:   62:
        -:   63:#ifndef SHUT_WR
        -:   64:#define SHUT_WR 1
        -:   65:#endif
        -:   66:
        -:   67:#ifndef HAVE_INT64T
        -:   68:typedef long long int64_t;
        -:   69:#endif
        -:   70:
        -:   71://added by shen
        -:   72:static count = 0;
        -:   73:static unsigned long long i = 0;
        -:   74:void __gcov_flush(void); /* check in gcc sources gcc/gcov-io.h for the
        -:   75:prototype */
    #####:   76:void my_handler(int signum)
        -:   77:{
    #####:   78:  printf("received signal\n");
    #####:   79:  printf("%llu\n", i);
    #####:   80:  __gcov_flush(); /* dump coverage data on receiving SIGUSR1 */
    #####:   81:  printf("flushed\n");
    #####:   82:  exit(0);
        -:   83:}
        -:   84:
        -:   85:static char* argv0;
        -:   86:static int debug;
        -:   87:static unsigned short port;
        -:   88:static char* dir;
        -:   89:static char* data_dir;
        -:   90:static int do_chroot, no_log, no_symlink_check, do_vhost, do_global_passwd;
        -:   91:static char* cgi_pattern;
        -:   92:static int cgi_limit;
        -:   93:static char* url_pattern;
        -:   94:static int no_empty_referrers;
        -:   95:static char* local_pattern;
        -:   96:static char* logfile;
        -:   97:static char* throttlefile;
        -:   98:static char* hostname;
        -:   99:static char* pidfile;
        -:  100:static char* user;
        -:  101:static char* charset;
        -:  102:static char* p3p;
        -:  103:static int max_age;
        -:  104:
        -:  105:
        -:  106:typedef struct {
        -:  107:    char* pattern;
        -:  108:    long max_limit, min_limit;
        -:  109:    long rate;
        -:  110:    off_t bytes_since_avg;
        -:  111:    int num_sending;
        -:  112:    } throttletab;
        -:  113:static throttletab* throttles;
        -:  114:static int numthrottles, maxthrottles;
        -:  115:
        -:  116:#define THROTTLE_NOLIMIT -1
        -:  117:
        -:  118:
        -:  119:typedef struct {
        -:  120:    int conn_state;
        -:  121:    int next_free_connect;
        -:  122:    httpd_conn* hc;
        -:  123:    int tnums[MAXTHROTTLENUMS];         /* throttle indexes */
        -:  124:    int numtnums;
        -:  125:    long max_limit, min_limit;
        -:  126:    time_t started_at, active_at;
        -:  127:    Timer* wakeup_timer;
        -:  128:    Timer* linger_timer;
        -:  129:    long wouldblock_delay;
        -:  130:    off_t bytes;
        -:  131:    off_t end_byte_index;
        -:  132:    off_t next_byte_index;
        -:  133:    } connecttab;
        -:  134:static connecttab* connects;
        -:  135:static int num_connects, max_connects, first_free_connect;
        -:  136:static int httpd_conn_count;
        -:  137:
        -:  138:/* The connection states. */
        -:  139:#define CNST_FREE 0
        -:  140:#define CNST_READING 1
        -:  141:#define CNST_SENDING 2
        -:  142:#define CNST_PAUSING 3
        -:  143:#define CNST_LINGERING 4
        -:  144:
        -:  145:
        -:  146:static httpd_server* hs = (httpd_server*) 0;
        -:  147:int terminate = 0;
        -:  148:time_t start_time, stats_time;
        -:  149:long stats_connections;
        -:  150:off_t stats_bytes;
        -:  151:int stats_simultaneous;
        -:  152:
        -:  153:static volatile int got_hup, got_usr1, watchdog_flag;
        -:  154:
        -:  155:
        -:  156:/* Forwards. */
        -:  157:static void parse_args( int argc, char** argv );
        -:  158:static void usage( void );
        -:  159:static void read_config( char* filename );
        -:  160:static void value_required( char* name, char* value );
        -:  161:static void no_value_required( char* name, char* value );
        -:  162:static char* e_strdup( char* oldstr );
        -:  163:static void lookup_hostname( httpd_sockaddr* sa4P, size_t sa4_len, int* gotv4P, httpd_sockaddr* sa6P, size_t sa6_len, int* gotv6P );
        -:  164:static void read_throttlefile( char* tf );
        -:  165:static void shut_down( void );
        -:  166:static int handle_newconnect( struct timeval* tvP, int listen_fd );
        -:  167:static void handle_read( connecttab* c, struct timeval* tvP );
        -:  168:static void handle_send( connecttab* c, struct timeval* tvP );
        -:  169:static void handle_linger( connecttab* c, struct timeval* tvP );
        -:  170:static int check_throttles( connecttab* c );
        -:  171:static void clear_throttles( connecttab* c, struct timeval* tvP );
        -:  172:static void update_throttles( ClientData client_data, struct timeval* nowP );
        -:  173:static void finish_connection( connecttab* c, struct timeval* tvP );
        -:  174:static void clear_connection( connecttab* c, struct timeval* tvP );
        -:  175:static void really_clear_connection( connecttab* c, struct timeval* tvP );
        -:  176:static void idle( ClientData client_data, struct timeval* nowP );
        -:  177:static void wakeup_connection( ClientData client_data, struct timeval* nowP );
        -:  178:static void linger_clear_connection( ClientData client_data, struct timeval* nowP );
        -:  179:static void occasional( ClientData client_data, struct timeval* nowP );
        -:  180:#ifdef STATS_TIME
        -:  181:static void show_stats( ClientData client_data, struct timeval* nowP );
        -:  182:#endif /* STATS_TIME */
        -:  183:static void logstats( struct timeval* nowP );
        -:  184:static void thttpd_logstats( long secs );
        -:  185:
        -:  186:
        -:  187:/* SIGTERM and SIGINT say to exit immediately. */
        -:  188:static void
    #####:  189:handle_term( int sig )
        -:  190:    {
        -:  191:    /* Don't need to set up the handler again, since it's a one-shot. */
        -:  192:
    #####:  193:    shut_down();
    #####:  194:    syslog( LOG_NOTICE, "exiting due to signal %d", sig );
    #####:  195:    closelog();
    #####:  196:    exit( 1 );
        -:  197:    }
        -:  198:
        -:  199:
        -:  200:/* SIGCHLD - a chile process exitted, so we need to reap the zombie */
        -:  201:static void
    #####:  202:handle_chld( int sig )
        -:  203:    {
    #####:  204:    const int oerrno = errno;
        -:  205:    pid_t pid;
        -:  206:    int status;
        -:  207:
        -:  208:#ifndef HAVE_SIGSET
        -:  209:    /* Set up handler again. */
        -:  210:    (void) signal( SIGCHLD, handle_chld );
        -:  211:#endif /* ! HAVE_SIGSET */
        -:  212:
        -:  213:    /* Reap defunct children until there aren't any more. */
        -:  214:    for (;;)
        -:  215:	{
        -:  216:#ifdef HAVE_WAITPID
    #####:  217:	pid = waitpid( (pid_t) -1, &status, WNOHANG );
        -:  218:#else /* HAVE_WAITPID */
        -:  219:	pid = wait3( &status, WNOHANG, (struct rusage*) 0 );
        -:  220:#endif /* HAVE_WAITPID */
    #####:  221:	if ( (int) pid == 0 )		/* none left */
    #####:  222:	    break;
    #####:  223:	if ( (int) pid < 0 )
        -:  224:	    {
    #####:  225:	    if ( errno == EINTR || errno == EAGAIN )
    #####:  226:		continue;
        -:  227:	    /* ECHILD shouldn't happen with the WNOHANG option,
        -:  228:	    ** but with some kernels it does anyway.  Ignore it.
        -:  229:	    */
    #####:  230:	    if ( errno != ECHILD )
    #####:  231:		syslog( LOG_ERR, "child wait - %m" );
    #####:  232:	    break;
        -:  233:	    }
        -:  234:	/* Decrement the CGI count.  Note that this is not accurate, since
        -:  235:	** each CGI can involve two or even three child processes.
        -:  236:	** Decrementing for each child means that when there is heavy CGI
        -:  237:	** activity, the count will be lower than it should be, and therefore
        -:  238:	** more CGIs will be allowed than should be.
        -:  239:	*/
    #####:  240:	if ( hs != (httpd_server*) 0 )
        -:  241:	    {
    #####:  242:	    --hs->cgi_count;
    #####:  243:	    if ( hs->cgi_count < 0 )
    #####:  244:		hs->cgi_count = 0;
        -:  245:	    }
    #####:  246:	}
        -:  247:
        -:  248:    /* Restore previous errno. */
    #####:  249:    errno = oerrno;
    #####:  250:    }
        -:  251:
        -:  252:
        -:  253:/* SIGHUP says to re-open the log file. */
        -:  254:static void
    #####:  255:handle_hup( int sig )
        -:  256:    {
    #####:  257:    const int oerrno = errno;
        -:  258:
        -:  259:#ifndef HAVE_SIGSET
        -:  260:    /* Set up handler again. */
        -:  261:    (void) signal( SIGHUP, handle_hup );
        -:  262:#endif /* ! HAVE_SIGSET */
        -:  263:
        -:  264:    /* Just set a flag that we got the signal. */
    #####:  265:    got_hup = 1;
        -:  266:
        -:  267:    /* Restore previous errno. */
    #####:  268:    errno = oerrno;
    #####:  269:    }
        -:  270:
        -:  271:
        -:  272:/* SIGUSR1 says to exit as soon as all current connections are done. */
        -:  273:static void
    #####:  274:handle_usr1( int sig )
        -:  275:    {
        -:  276:    /* Don't need to set up the handler again, since it's a one-shot. */
        -:  277:
    #####:  278:    if ( num_connects == 0 )
        -:  279:	{
        -:  280:	/* If there are no active connections we want to exit immediately
        -:  281:	** here.  Not only is it faster, but without any connections the
        -:  282:	** main loop won't wake up until the next new connection.
        -:  283:	*/
    #####:  284:	shut_down();
    #####:  285:	syslog( LOG_NOTICE, "exiting" );
    #####:  286:	closelog();
    #####:  287:	exit( 0 );
        -:  288:	}
        -:  289:
        -:  290:    /* Otherwise, just set a flag that we got the signal. */
    #####:  291:    got_usr1 = 1;
        -:  292:
        -:  293:    /* Don't need to restore old errno, since we didn't do any syscalls. */
    #####:  294:    }
        -:  295:
        -:  296:
        -:  297:/* SIGUSR2 says to generate the stats syslogs immediately. */
        -:  298:static void
    #####:  299:handle_usr2( int sig )
        -:  300:    {
    #####:  301:    const int oerrno = errno;
        -:  302:
        -:  303:#ifndef HAVE_SIGSET
        -:  304:    /* Set up handler again. */
        -:  305:    (void) signal( SIGUSR2, handle_usr2 );
        -:  306:#endif /* ! HAVE_SIGSET */
        -:  307:
    #####:  308:    logstats( (struct timeval*) 0 );
        -:  309:
        -:  310:    /* Restore previous errno. */
    #####:  311:    errno = oerrno;
    #####:  312:    }
        -:  313:
        -:  314:
        -:  315:/* SIGALRM is used as a watchdog. */
        -:  316:static void
    #####:  317:handle_alrm( int sig )
        -:  318:    {
    #####:  319:    const int oerrno = errno;
        -:  320:
        -:  321:    /* If nothing has been happening */
    #####:  322:    if ( ! watchdog_flag )
        -:  323:	{
        -:  324:	/* Try changing dirs to someplace we can write. */
    #####:  325:	(void) chdir( "/tmp" );
        -:  326:	/* Dump core. */
    #####:  327:	abort();
        -:  328:	}
    #####:  329:    watchdog_flag = 0;
        -:  330:
        -:  331:#ifndef HAVE_SIGSET
        -:  332:    /* Set up handler again. */
        -:  333:    (void) signal( SIGALRM, handle_alrm );
        -:  334:#endif /* ! HAVE_SIGSET */
        -:  335:    /* Set up alarm again. */
    #####:  336:    (void) alarm( OCCASIONAL_TIME * 3 );
        -:  337:
        -:  338:    /* Restore previous errno. */
    #####:  339:    errno = oerrno;
    #####:  340:    }
        -:  341:
        -:  342:
        -:  343:static void
    #####:  344:re_open_logfile( void )
        -:  345:    {
        -:  346:    FILE* logfp;
        -:  347:
    #####:  348:    if ( no_log || hs == (httpd_server*) 0 )
    #####:  349:	return;
        -:  350:
        -:  351:    /* Re-open the log file. */
    #####:  352:    if ( logfile != (char*) 0 && strcmp( logfile, "-" ) != 0 )
        -:  353:	{
    #####:  354:	syslog( LOG_NOTICE, "re-opening logfile" );
    #####:  355:	logfp = fopen( logfile, "a" );
    #####:  356:	if ( logfp == (FILE*) 0 )
        -:  357:	    {
    #####:  358:	    syslog( LOG_CRIT, "re-opening %.80s - %m", logfile );
    #####:  359:	    return;
        -:  360:	    }
    #####:  361:	(void) fcntl( fileno( logfp ), F_SETFD, 1 );
    #####:  362:	httpd_set_logfp( hs, logfp );
        -:  363:	}
        -:  364:    }
        -:  365:
        -:  366:
        -:  367:int
        1:  368:main( int argc, char** argv )
        -:  369:    {
        -:  370:    char* cp;
        -:  371:    struct passwd* pwd;
        1:  372:    uid_t uid = 32767;
        1:  373:    gid_t gid = 32767;
        -:  374:    char cwd[MAXPATHLEN+1];
        -:  375:    FILE* logfp;
        -:  376:    int num_ready;
        -:  377:    int cnum;
        -:  378:    connecttab* c;
        -:  379:    httpd_conn* hc;
        -:  380:    httpd_sockaddr sa4;
        -:  381:    httpd_sockaddr sa6;
        -:  382:    int gotv4, gotv6;
        -:  383:    struct timeval tv;
        -:  384:
        1:  385:    argv0 = argv[0];
        -:  386:
        1:  387:    cp = strrchr( argv0, '/' );
        1:  388:    if ( cp != (char*) 0 )
        1:  389:	++cp;
        -:  390:    else
    #####:  391:	cp = argv0;
        1:  392:    openlog( cp, LOG_NDELAY|LOG_PID, LOG_FACILITY );
        -:  393:
        -:  394:    /* Handle command-line arguments. */
        1:  395:    parse_args( argc, argv );
        -:  396:
        -:  397:    /* Read zone info now, in case we chroot(). */
        1:  398:    tzset();
        -:  399:
        -:  400:    /* Look up hostname now, in case we chroot(). */
        1:  401:    lookup_hostname( &sa4, sizeof(sa4), &gotv4, &sa6, sizeof(sa6), &gotv6 );
        1:  402:    if ( ! ( gotv4 || gotv6 ) )
        -:  403:	{
    #####:  404:	syslog( LOG_ERR, "can't find any valid address" );
    #####:  405:	(void) fprintf( stderr, "%s: can't find any valid address\n", argv0 );
    #####:  406:	exit( 1 );
        -:  407:	}
        -:  408:
        -:  409:    /* Throttle file. */
        1:  410:    numthrottles = 0;
        1:  411:    maxthrottles = 0;
        1:  412:    throttles = (throttletab*) 0;
        1:  413:    if ( throttlefile != (char*) 0 )
    #####:  414:	read_throttlefile( throttlefile );
        -:  415:
        -:  416:    /* If we're root and we're going to become another user, get the uid/gid
        -:  417:    ** now.
        -:  418:    */
        1:  419:    if ( getuid() == 0 )
        -:  420:	{
        1:  421:	pwd = getpwnam( user );
        1:  422:	if ( pwd == (struct passwd*) 0 )
        -:  423:	    {
        1:  424:	    syslog( LOG_CRIT, "unknown user - '%.80s'", user );
        1:  425:	    (void) fprintf( stderr, "%s: unknown user - '%s'\n", argv0, user );
        1:  426:	    exit( 1 );
        -:  427:	    }
    #####:  428:	uid = pwd->pw_uid;
    #####:  429:	gid = pwd->pw_gid;
        -:  430:	}
        -:  431:
        -:  432:    /* Log file. */
    #####:  433:    if ( logfile != (char*) 0 )
        -:  434:	{
    #####:  435:	if ( strcmp( logfile, "/dev/null" ) == 0 )
        -:  436:	    {
    #####:  437:	    no_log = 1;
    #####:  438:	    logfp = (FILE*) 0;
        -:  439:	    }
    #####:  440:	else if ( strcmp( logfile, "-" ) == 0 )
    #####:  441:	    logfp = stdout;
        -:  442:	else
        -:  443:	    {
    #####:  444:	    logfp = fopen( logfile, "a" );
    #####:  445:	    if ( logfp == (FILE*) 0 )
        -:  446:		{
    #####:  447:		syslog( LOG_CRIT, "%.80s - %m", logfile );
    #####:  448:		perror( logfile );
    #####:  449:		exit( 1 );
        -:  450:		}
    #####:  451:	    if ( logfile[0] != '/' )
        -:  452:		{
    #####:  453:		syslog( LOG_WARNING, "logfile is not an absolute path, you may not be able to re-open it" );
    #####:  454:		(void) fprintf( stderr, "%s: logfile is not an absolute path, you may not be able to re-open it\n", argv0 );
        -:  455:		}
    #####:  456:	    (void) fcntl( fileno( logfp ), F_SETFD, 1 );
    #####:  457:	    if ( getuid() == 0 )
        -:  458:		{
        -:  459:		/* If we are root then we chown the log file to the user we'll
        -:  460:		** be switching to.
        -:  461:		*/
    #####:  462:		if ( fchown( fileno( logfp ), uid, gid ) < 0 )
        -:  463:		    {
    #####:  464:		    syslog( LOG_WARNING, "fchown logfile - %m" );
    #####:  465:		    perror( "fchown logfile" );
        -:  466:		    }
        -:  467:		}
        -:  468:	    }
        -:  469:	}
        -:  470:    else
    #####:  471:	logfp = (FILE*) 0;
        -:  472:
        -:  473:    /* Switch directories if requested. */
    #####:  474:    if ( dir != (char*) 0 )
        -:  475:	{
    #####:  476:	if ( chdir( dir ) < 0 )
        -:  477:	    {
    #####:  478:	    syslog( LOG_CRIT, "chdir - %m" );
    #####:  479:	    perror( "chdir" );
    #####:  480:	    exit( 1 );
        -:  481:	    }
        -:  482:	}
        -:  483:#ifdef USE_USER_DIR
        -:  484:    else if ( getuid() == 0 )
        -:  485:	{
        -:  486:	/* No explicit directory was specified, we're root, and the
        -:  487:	** USE_USER_DIR option is set - switch to the specified user's
        -:  488:	** home dir.
        -:  489:	*/
        -:  490:	if ( chdir( pwd->pw_dir ) < 0 )
        -:  491:	    {
        -:  492:	    syslog( LOG_CRIT, "chdir - %m" );
        -:  493:	    perror( "chdir" );
        -:  494:	    exit( 1 );
        -:  495:	    }
        -:  496:	}
        -:  497:#endif /* USE_USER_DIR */
        -:  498:
        -:  499:    /* Get current directory. */
    #####:  500:    (void) getcwd( cwd, sizeof(cwd) - 1 );
    #####:  501:    if ( cwd[strlen( cwd ) - 1] != '/' )
    #####:  502:	(void) strcat( cwd, "/" );
        -:  503:
    #####:  504:    if ( ! debug )
        -:  505:	{
        -:  506:	/* We're not going to use stdin stdout or stderr from here on, so close
        -:  507:	** them to save file descriptors.
        -:  508:	*/
    #####:  509:	(void) fclose( stdin );
    #####:  510:	if ( logfp != stdout )
    #####:  511:	    (void) fclose( stdout );
    #####:  512:	(void) fclose( stderr );
        -:  513:
        -:  514:	/* Daemonize - make ourselves a subprocess. */
        -:  515:#ifdef HAVE_DAEMON
    #####:  516:	if ( daemon( 1, 1 ) < 0 )
        -:  517:	    {
    #####:  518:	    syslog( LOG_CRIT, "daemon - %m" );
    #####:  519:	    exit( 1 );
        -:  520:	    }
        -:  521:#else /* HAVE_DAEMON */
        -:  522:	switch ( fork() )
        -:  523:	    {
        -:  524:	    case 0:
        -:  525:	    break;
        -:  526:	    case -1:
        -:  527:	    syslog( LOG_CRIT, "fork - %m" );
        -:  528:	    exit( 1 );
        -:  529:	    default:
        -:  530:	    exit( 0 );
        -:  531:	    }
        -:  532:#ifdef HAVE_SETSID
        -:  533:        (void) setsid();
        -:  534:#endif /* HAVE_SETSID */
        -:  535:#endif /* HAVE_DAEMON */
        -:  536:	}
        -:  537:    else
        -:  538:	{
        -:  539:	/* Even if we don't daemonize, we still want to disown our parent
        -:  540:	** process.
        -:  541:	*/
        -:  542:#ifdef HAVE_SETSID
    #####:  543:        (void) setsid();
        -:  544:#endif /* HAVE_SETSID */
        -:  545:	}
        -:  546:
    #####:  547:    if ( pidfile != (char*) 0 )
        -:  548:	{
        -:  549:	/* Write the PID file. */
    #####:  550:	FILE* pidfp = fopen( pidfile, "w" );
    #####:  551:	if ( pidfp == (FILE*) 0 )
        -:  552:	    {
    #####:  553:	    syslog( LOG_CRIT, "%.80s - %m", pidfile );
    #####:  554:	    exit( 1 );
        -:  555:	    }
    #####:  556:	(void) fprintf( pidfp, "%d\n", (int) getpid() );
    #####:  557:	(void) fclose( pidfp );
        -:  558:	}
        -:  559:
        -:  560:    /* Initialize the fdwatch package.  Have to do this before chroot,
        -:  561:    ** if /dev/poll is used.
        -:  562:    */
    #####:  563:    max_connects = fdwatch_get_nfiles();
    #####:  564:    if ( max_connects < 0 )
        -:  565:	{
    #####:  566:	syslog( LOG_CRIT, "fdwatch initialization failure" );
    #####:  567:	exit( 1 );
        -:  568:	}
    #####:  569:    max_connects -= SPARE_FDS;
        -:  570:
        -:  571:    /* Chroot if requested. */
    #####:  572:    if ( do_chroot )
        -:  573:	{
    #####:  574:	if ( chroot( cwd ) < 0 )
        -:  575:	    {
    #####:  576:	    syslog( LOG_CRIT, "chroot - %m" );
    #####:  577:	    perror( "chroot" );
    #####:  578:	    exit( 1 );
        -:  579:	    }
        -:  580:	/* If we're logging and the logfile's pathname begins with the
        -:  581:	** chroot tree's pathname, then elide the chroot pathname so
        -:  582:	** that the logfile pathname still works from inside the chroot
        -:  583:	** tree.
        -:  584:	*/
    #####:  585:	if ( logfile != (char*) 0 && strcmp( logfile, "-" ) != 0 )
        -:  586:	    {
    #####:  587:	    if ( strncmp( logfile, cwd, strlen( cwd ) ) == 0 )
        -:  588:		{
    #####:  589:		(void) ol_strcpy( logfile, &logfile[strlen( cwd ) - 1] );
        -:  590:		/* (We already guaranteed that cwd ends with a slash, so leaving
        -:  591:		** that slash in logfile makes it an absolute pathname within
        -:  592:		** the chroot tree.)
        -:  593:		*/
        -:  594:		}
        -:  595:	    else
        -:  596:		{
    #####:  597:		syslog( LOG_WARNING, "logfile is not within the chroot tree, you will not be able to re-open it" );
    #####:  598:		(void) fprintf( stderr, "%s: logfile is not within the chroot tree, you will not be able to re-open it\n", argv0 );
        -:  599:		}
        -:  600:	    }
    #####:  601:	(void) strcpy( cwd, "/" );
        -:  602:	/* Always chdir to / after a chroot. */
    #####:  603:	if ( chdir( cwd ) < 0 )
        -:  604:	    {
    #####:  605:	    syslog( LOG_CRIT, "chroot chdir - %m" );
    #####:  606:	    perror( "chroot chdir" );
    #####:  607:	    exit( 1 );
        -:  608:	    }
        -:  609:	}
        -:  610:
        -:  611:    /* Switch directories again if requested. */
    #####:  612:    if ( data_dir != (char*) 0 )
        -:  613:	{
    #####:  614:	if ( chdir( data_dir ) < 0 )
        -:  615:	    {
    #####:  616:	    syslog( LOG_CRIT, "data_dir chdir - %m" );
    #####:  617:	    perror( "data_dir chdir" );
    #####:  618:	    exit( 1 );
        -:  619:	    }
        -:  620:	}
        -:  621:
        -:  622:    /* Set up to catch signals. */
        -:  623:#ifdef HAVE_SIGSET
    #####:  624:    (void) sigset( SIGTERM, handle_term );
    #####:  625:    (void) sigset( SIGINT, handle_term );
    #####:  626:    (void) sigset( SIGCHLD, handle_chld );
    #####:  627:    (void) sigset( SIGPIPE, SIG_IGN );          /* get EPIPE instead */
    #####:  628:    (void) sigset( SIGHUP, handle_hup );
    #####:  629:    (void) sigset( SIGUSR1, handle_usr1 );
    #####:  630:    (void) sigset( SIGUSR2, handle_usr2 );
    #####:  631:    (void) sigset( SIGALRM, handle_alrm );
        -:  632:#else /* HAVE_SIGSET */
        -:  633:    (void) signal( SIGTERM, handle_term );
        -:  634:    (void) signal( SIGINT, handle_term );
        -:  635:    (void) signal( SIGCHLD, handle_chld );
        -:  636:    (void) signal( SIGPIPE, SIG_IGN );          /* get EPIPE instead */
        -:  637:    (void) signal( SIGHUP, handle_hup );
        -:  638:    (void) signal( SIGUSR1, handle_usr1 );
        -:  639:    (void) signal( SIGUSR2, handle_usr2 );
        -:  640:    (void) signal( SIGALRM, handle_alrm );
        -:  641:#endif /* HAVE_SIGSET */
    #####:  642:    got_hup = 0;
    #####:  643:    got_usr1 = 0;
    #####:  644:    watchdog_flag = 0;
    #####:  645:    (void) alarm( OCCASIONAL_TIME * 3 );
        -:  646:
        -:  647:    /* Initialize the timer package. */
    #####:  648:    tmr_init();
        -:  649:
        -:  650:    /* Initialize the HTTP layer.  Got to do this before giving up root,
        -:  651:    ** so that we can bind to a privileged port.
        -:  652:    */
    #####:  653:    hs = httpd_initialize(
        -:  654:	hostname,
    #####:  655:	gotv4 ? &sa4 : (httpd_sockaddr*) 0, gotv6 ? &sa6 : (httpd_sockaddr*) 0,
        -:  656:	port, cgi_pattern, cgi_limit, charset, p3p, max_age, cwd, no_log, logfp,
        -:  657:	no_symlink_check, do_vhost, do_global_passwd, url_pattern,
        -:  658:	local_pattern, no_empty_referrers );
    #####:  659:    if ( hs == (httpd_server*) 0 )
    #####:  660:	exit( 1 );
        -:  661:
        -:  662:    /* Set up the occasional timer. */
    #####:  663:    if ( tmr_create( (struct timeval*) 0, occasional, JunkClientData, OCCASIONAL_TIME * 1000L, 1 ) == (Timer*) 0 )
        -:  664:	{
    #####:  665:	syslog( LOG_CRIT, "tmr_create(occasional) failed" );
    #####:  666:	exit( 1 );
        -:  667:	}
        -:  668:    /* Set up the idle timer. */
    #####:  669:    if ( tmr_create( (struct timeval*) 0, idle, JunkClientData, 5 * 1000L, 1 ) == (Timer*) 0 )
        -:  670:	{
    #####:  671:	syslog( LOG_CRIT, "tmr_create(idle) failed" );
    #####:  672:	exit( 1 );
        -:  673:	}
    #####:  674:    if ( numthrottles > 0 )
        -:  675:	{
        -:  676:	/* Set up the throttles timer. */
    #####:  677:	if ( tmr_create( (struct timeval*) 0, update_throttles, JunkClientData, THROTTLE_TIME * 1000L, 1 ) == (Timer*) 0 )
        -:  678:	    {
    #####:  679:	    syslog( LOG_CRIT, "tmr_create(update_throttles) failed" );
    #####:  680:	    exit( 1 );
        -:  681:	    }
        -:  682:	}
        -:  683:#ifdef STATS_TIME
        -:  684:    /* Set up the stats timer. */
    #####:  685:    if ( tmr_create( (struct timeval*) 0, show_stats, JunkClientData, STATS_TIME * 1000L, 1 ) == (Timer*) 0 )
        -:  686:	{
    #####:  687:	syslog( LOG_CRIT, "tmr_create(show_stats) failed" );
    #####:  688:	exit( 1 );
        -:  689:	}
        -:  690:#endif /* STATS_TIME */
    #####:  691:    start_time = stats_time = time( (time_t*) 0 );
    #####:  692:    stats_connections = 0;
    #####:  693:    stats_bytes = 0;
    #####:  694:    stats_simultaneous = 0;
        -:  695:
        -:  696:    /* If we're root, try to become someone else. */
    #####:  697:    if ( getuid() == 0 )
        -:  698:	{
        -:  699:	/* Set aux groups to null. */
    #####:  700:	if ( setgroups( 0, (const gid_t*) 0 ) < 0 )
        -:  701:	    {
    #####:  702:	    syslog( LOG_CRIT, "setgroups - %m" );
    #####:  703:	    exit( 1 );
        -:  704:	    }
        -:  705:	/* Set primary group. */
    #####:  706:	if ( setgid( gid ) < 0 )
        -:  707:	    {
    #####:  708:	    syslog( LOG_CRIT, "setgid - %m" );
    #####:  709:	    exit( 1 );
        -:  710:	    }
        -:  711:	/* Try setting aux groups correctly - not critical if this fails. */
    #####:  712:	if ( initgroups( user, gid ) < 0 )
    #####:  713:	    syslog( LOG_WARNING, "initgroups - %m" );
        -:  714:#ifdef HAVE_SETLOGIN
        -:  715:	/* Set login name. */
        -:  716:        (void) setlogin( user );
        -:  717:#endif /* HAVE_SETLOGIN */
        -:  718:	/* Set uid. */
    #####:  719:	if ( setuid( uid ) < 0 )
        -:  720:	    {
    #####:  721:	    syslog( LOG_CRIT, "setuid - %m" );
    #####:  722:	    exit( 1 );
        -:  723:	    }
        -:  724:	/* Check for unnecessary security exposure. */
    #####:  725:	if ( ! do_chroot )
    #####:  726:	    syslog(
        -:  727:		LOG_WARNING,
        -:  728:		"started as root without requesting chroot(), warning only" );
        -:  729:	}
        -:  730:
        -:  731:    /* Initialize our connections table. */
    #####:  732:    connects = NEW( connecttab, max_connects );
    #####:  733:    if ( connects == (connecttab*) 0 )
        -:  734:	{
    #####:  735:	syslog( LOG_CRIT, "out of memory allocating a connecttab" );
    #####:  736:	exit( 1 );
        -:  737:	}
    #####:  738:    for ( cnum = 0; cnum < max_connects; ++cnum )
        -:  739:	{
    #####:  740:	connects[cnum].conn_state = CNST_FREE;
    #####:  741:	connects[cnum].next_free_connect = cnum + 1;
    #####:  742:	connects[cnum].hc = (httpd_conn*) 0;
        -:  743:	}
    #####:  744:    connects[max_connects - 1].next_free_connect = -1;	/* end of link list */
    #####:  745:    first_free_connect = 0;
    #####:  746:    num_connects = 0;
    #####:  747:    httpd_conn_count = 0;
        -:  748:
    #####:  749:    if ( hs != (httpd_server*) 0 )
        -:  750:	{
    #####:  751:	if ( hs->listen4_fd != -1 )
    #####:  752:	    fdwatch_add_fd( hs->listen4_fd, (void*) 0, FDW_READ );
    #####:  753:	if ( hs->listen6_fd != -1 )
    #####:  754:	    fdwatch_add_fd( hs->listen6_fd, (void*) 0, FDW_READ );
        -:  755:	}
        -:  756:
        -:  757:	//added by shen, SIG handler for terminating server with kill 9 from another terminal
        -:  758: struct sigaction new_action, old_action;
        -:  759:  /* setup signal hander */
    #####:  760:  new_action.sa_handler = my_handler;
    #####:  761:  sigemptyset(&new_action.sa_mask);
    #####:  762:  new_action.sa_flags = 0;
    #####:  763:  sigaction(SIGUSR1, NULL, &old_action);
    #####:  764:  if (old_action.sa_handler != SIG_IGN)
    #####:  765:    sigaction (SIGUSR1, &new_action, NULL);
        -:  766:
        -:  767:
        -:  768:    /* Main loop. */
    #####:  769:    (void) gettimeofday( &tv, (struct timezone*) 0 );
    #####:  770:    while ( ( ! terminate ) || num_connects > 0 )
        -:  771:	{
        -:  772:	/* Do we need to re-open the log file? */
    #####:  773:	if ( got_hup )
        -:  774:	    {
    #####:  775:	    re_open_logfile();
    #####:  776:	    got_hup = 0;
        -:  777:	    }
        -:  778:
        -:  779:	/* Do the fd watch. */
    #####:  780:	num_ready = fdwatch( tmr_mstimeout( &tv ) );
    #####:  781:	if ( num_ready < 0 )
        -:  782:	    {
    #####:  783:	    if ( errno == EINTR || errno == EAGAIN )
    #####:  784:		continue;       /* try again */
    #####:  785:	    syslog( LOG_ERR, "fdwatch - %m" );
    #####:  786:	    exit( 1 );
        -:  787:	    }
    #####:  788:	(void) gettimeofday( &tv, (struct timezone*) 0 );
        -:  789:
    #####:  790:	if ( num_ready == 0 )
        -:  791:	    {
        -:  792:	    /* No fd's are ready - run the timers. */
    #####:  793:	    tmr_run( &tv );
    #####:  794:	    continue;
        -:  795:	    }
        -:  796:
        -:  797:	/* Is it a new connection? */
    #####:  798:	if ( hs != (httpd_server*) 0 && hs->listen6_fd != -1 &&
    #####:  799:	     fdwatch_check_fd( hs->listen6_fd ) )
        -:  800:	    {
    #####:  801:	    if ( handle_newconnect( &tv, hs->listen6_fd ) )
        -:  802:		/* Go around the loop and do another fdwatch, rather than
        -:  803:		** dropping through and processing existing connections.
        -:  804:		** New connections always get priority.
        -:  805:		*/
    #####:  806:		continue;
        -:  807:	    }
    #####:  808:	if ( hs != (httpd_server*) 0 && hs->listen4_fd != -1 &&
    #####:  809:	     fdwatch_check_fd( hs->listen4_fd ) )
        -:  810:	    {
    #####:  811:	    if ( handle_newconnect( &tv, hs->listen4_fd ) )
        -:  812:		/* Go around the loop and do another fdwatch, rather than
        -:  813:		** dropping through and processing existing connections.
        -:  814:		** New connections always get priority.
        -:  815:		*/
    #####:  816:		continue;
        -:  817:	    }
        -:  818:
        -:  819:	/* Find the connections that need servicing. */
    #####:  820:	while ( ( c = (connecttab*) fdwatch_get_next_client_data() ) != (connecttab*) -1 )
        -:  821:	    {
    #####:  822:	    if ( c == (connecttab*) 0 )
    #####:  823:		continue;
    #####:  824:	    hc = c->hc;
    #####:  825:	    if ( ! fdwatch_check_fd( hc->conn_fd ) )
        -:  826:		/* Something went wrong. */
    #####:  827:		clear_connection( c, &tv );
        -:  828:	    else
    #####:  829:		switch ( c->conn_state )
        -:  830:		    {
    #####:  831:		    case CNST_READING: handle_read( c, &tv ); break;
    #####:  832:		    case CNST_SENDING: handle_send( c, &tv ); break;
    #####:  833:		    case CNST_LINGERING: handle_linger( c, &tv ); break;
        -:  834:		    }
        -:  835:	    }
        -:  836:
    #####:  837:	printf(" DEBUG before tmr_run...\n");
    #####:  838:	tmr_run( &tv );
    #####:  839:	printf(" DEBUG after tmr_run...\n");
        -:  840:	
        -:  841:	//clear_connection( connecttab* c, struct timeval* tvP );
        -:  842:	//clear_connection( c, &tv ); //added by shen 20180422
    #####:  843:	printf("num_connects: %d count = %d\n", num_connects, count++);
        -:  844://	if(count == 4)
        -:  845://		handle_usr1(SIGUSR1);
        -:  846:
        -:  847:	//terminate = 1;//added by shen
    #####:  848:	if ( got_usr1 && ! terminate )
        -:  849:	    {
        -:  850:	
    #####:  851:	    terminate = 1;
    #####:  852:	    if ( hs != (httpd_server*) 0 )
        -:  853:		{
    #####:  854:		if ( hs->listen4_fd != -1 )
    #####:  855:		    fdwatch_del_fd( hs->listen4_fd );
    #####:  856:		if ( hs->listen6_fd != -1 )
    #####:  857:		    fdwatch_del_fd( hs->listen6_fd );
    #####:  858:		httpd_unlisten( hs );
        -:  859:		}
        -:  860:	    }
    #####:  861:	printf(" DEBUG: still in while loop...");
        -:  862:
        -:  863:	}
        -:  864:	
        -:  865:
        -:  866:    /* The main loop terminated. */
    #####:  867:    shut_down();
    #####:  868:    syslog( LOG_NOTICE, "exiting" );
    #####:  869:    closelog();
    #####:  870:    exit( 0 );
        -:  871:    }
        -:  872:
        -:  873:
        -:  874:static void
        1:  875:parse_args( int argc, char** argv )
        -:  876:    {
        -:  877:    int argn;
        -:  878:
        1:  879:    debug = 0;
        1:  880:    port = DEFAULT_PORT;
        1:  881:    dir = (char*) 0;
        1:  882:    data_dir = (char*) 0;
        -:  883:#ifdef ALWAYS_CHROOT
        -:  884:    do_chroot = 1;
        -:  885:#else /* ALWAYS_CHROOT */
        1:  886:    do_chroot = 0;
        -:  887:#endif /* ALWAYS_CHROOT */
        1:  888:    no_log = 0;
        1:  889:    no_symlink_check = do_chroot;
        -:  890:#ifdef ALWAYS_VHOST
        -:  891:    do_vhost = 1;
        -:  892:#else /* ALWAYS_VHOST */
        1:  893:    do_vhost = 0;
        -:  894:#endif /* ALWAYS_VHOST */
        -:  895:#ifdef ALWAYS_GLOBAL_PASSWD
        -:  896:    do_global_passwd = 1;
        -:  897:#else /* ALWAYS_GLOBAL_PASSWD */
        1:  898:    do_global_passwd = 0;
        -:  899:#endif /* ALWAYS_GLOBAL_PASSWD */
        -:  900:#ifdef CGI_PATTERN
        -:  901:    cgi_pattern = CGI_PATTERN;
        -:  902:#else /* CGI_PATTERN */
        1:  903:    cgi_pattern = (char*) 0;
        -:  904:#endif /* CGI_PATTERN */
        -:  905:#ifdef CGI_LIMIT
        -:  906:    cgi_limit = CGI_LIMIT;
        -:  907:#else /* CGI_LIMIT */
        1:  908:    cgi_limit = 0;
        -:  909:#endif /* CGI_LIMIT */
        1:  910:    url_pattern = (char*) 0;
        1:  911:    no_empty_referrers = 0;
        1:  912:    local_pattern = (char*) 0;
        1:  913:    throttlefile = (char*) 0;
        1:  914:    hostname = (char*) 0;
        1:  915:    logfile = (char*) 0;
        1:  916:    pidfile = (char*) 0;
        1:  917:    user = DEFAULT_USER;
        1:  918:    charset = DEFAULT_CHARSET;
        1:  919:    p3p = "";
        1:  920:    max_age = -1;
        1:  921:    argn = 1;
        4:  922:    while ( argn < argc && argv[argn][0] == '-' )
        -:  923:	{
        2:  924:	if ( strcmp( argv[argn], "-V" ) == 0 )
        -:  925:	    {
    #####:  926:	    (void) printf( "%s\n", SERVER_SOFTWARE );
    #####:  927:	    exit( 0 );
        -:  928:	    }
        2:  929:	else if ( strcmp( argv[argn], "-C" ) == 0 && argn + 1 < argc )
        -:  930:	    {
        1:  931:	    ++argn;
        1:  932:	    read_config( argv[argn] );
        -:  933:	    }
        1:  934:	else if ( strcmp( argv[argn], "-p" ) == 0 && argn + 1 < argc )
        -:  935:	    {
    #####:  936:	    ++argn;
    #####:  937:	    port = (unsigned short) atoi( argv[argn] );
        -:  938:	    }
        1:  939:	else if ( strcmp( argv[argn], "-d" ) == 0 && argn + 1 < argc )
        -:  940:	    {
    #####:  941:	    ++argn;
    #####:  942:	    dir = argv[argn];
        -:  943:	    }
        1:  944:	else if ( strcmp( argv[argn], "-r" ) == 0 )
        -:  945:	    {
    #####:  946:	    do_chroot = 1;
    #####:  947:	    no_symlink_check = 1;
        -:  948:	    }
        1:  949:	else if ( strcmp( argv[argn], "-nor" ) == 0 )
        -:  950:	    {
    #####:  951:	    do_chroot = 0;
    #####:  952:	    no_symlink_check = 0;
        -:  953:	    }
        1:  954:	else if ( strcmp( argv[argn], "-dd" ) == 0 && argn + 1 < argc )
        -:  955:	    {
    #####:  956:	    ++argn;
    #####:  957:	    data_dir = argv[argn];
        -:  958:	    }
        1:  959:	else if ( strcmp( argv[argn], "-s" ) == 0 )
    #####:  960:	    no_symlink_check = 0;
        1:  961:	else if ( strcmp( argv[argn], "-nos" ) == 0 )
    #####:  962:	    no_symlink_check = 1;
        1:  963:	else if ( strcmp( argv[argn], "-u" ) == 0 && argn + 1 < argc )
        -:  964:	    {
    #####:  965:	    ++argn;
    #####:  966:	    user = argv[argn];
        -:  967:	    }
        1:  968:	else if ( strcmp( argv[argn], "-c" ) == 0 && argn + 1 < argc )
        -:  969:	    {
    #####:  970:	    ++argn;
    #####:  971:	    cgi_pattern = argv[argn];
        -:  972:	    }
        1:  973:	else if ( strcmp( argv[argn], "-t" ) == 0 && argn + 1 < argc )
        -:  974:	    {
    #####:  975:	    ++argn;
    #####:  976:	    throttlefile = argv[argn];
        -:  977:	    }
        1:  978:	else if ( strcmp( argv[argn], "-h" ) == 0 && argn + 1 < argc )
        -:  979:	    {
    #####:  980:	    ++argn;
    #####:  981:	    hostname = argv[argn];
        -:  982:	    }
        1:  983:	else if ( strcmp( argv[argn], "-l" ) == 0 && argn + 1 < argc )
        -:  984:	    {
    #####:  985:	    ++argn;
    #####:  986:	    logfile = argv[argn];
        -:  987:	    }
        1:  988:	else if ( strcmp( argv[argn], "-v" ) == 0 )
    #####:  989:	    do_vhost = 1;
        1:  990:	else if ( strcmp( argv[argn], "-nov" ) == 0 )
    #####:  991:	    do_vhost = 0;
        1:  992:	else if ( strcmp( argv[argn], "-g" ) == 0 )
    #####:  993:	    do_global_passwd = 1;
        1:  994:	else if ( strcmp( argv[argn], "-nog" ) == 0 )
    #####:  995:	    do_global_passwd = 0;
        1:  996:	else if ( strcmp( argv[argn], "-i" ) == 0 && argn + 1 < argc )
        -:  997:	    {
    #####:  998:	    ++argn;
    #####:  999:	    pidfile = argv[argn];
        -: 1000:	    }
        1: 1001:	else if ( strcmp( argv[argn], "-T" ) == 0 && argn + 1 < argc )
        -: 1002:	    {
    #####: 1003:	    ++argn;
    #####: 1004:	    charset = argv[argn];
        -: 1005:	    }
        1: 1006:	else if ( strcmp( argv[argn], "-P" ) == 0 && argn + 1 < argc )
        -: 1007:	    {
    #####: 1008:	    ++argn;
    #####: 1009:	    p3p = argv[argn];
        -: 1010:	    }
        1: 1011:	else if ( strcmp( argv[argn], "-M" ) == 0 && argn + 1 < argc )
        -: 1012:	    {
    #####: 1013:	    ++argn;
    #####: 1014:	    max_age = atoi( argv[argn] );
        -: 1015:	    }
        1: 1016:	else if ( strcmp( argv[argn], "-D" ) == 0 )
        1: 1017:	    debug = 1;
        -: 1018:	else
    #####: 1019:	    usage();
        2: 1020:	++argn;
        -: 1021:	}
        1: 1022:    if ( argn != argc )
    #####: 1023:	usage();
        1: 1024:    }
        -: 1025:
        -: 1026:
        -: 1027:static void
    #####: 1028:usage( void )
        -: 1029:    {
    #####: 1030:    (void) fprintf( stderr,
        -: 1031:"usage:  %s [-C configfile] [-p port] [-d dir] [-r|-nor] [-dd data_dir] [-s|-nos] [-v|-nov] [-g|-nog] [-u user] [-c cgipat] [-t throttles] [-h host] [-l logfile] [-i pidfile] [-T charset] [-P P3P] [-M maxage] [-V] [-D]\n",
        -: 1032:	argv0 );
    #####: 1033:    exit( 1 );
        -: 1034:    }
        -: 1035:
        -: 1036:
        -: 1037:static void
        1: 1038:read_config( char* filename )
        -: 1039:    {
        -: 1040:    FILE* fp;
        -: 1041:    char line[10000];
        -: 1042:    char* cp;
        -: 1043:    char* cp2;
        -: 1044:    char* name;
        -: 1045:    char* value;
        -: 1046:
        1: 1047:    fp = fopen( filename, "r" );
        1: 1048:    if ( fp == (FILE*) 0 )
        -: 1049:	{
    #####: 1050:	perror( filename );
    #####: 1051:	exit( 1 );
        -: 1052:	}
        -: 1053:
        7: 1054:    while ( fgets( line, sizeof(line), fp ) != (char*) 0 )
        -: 1055:	{
        -: 1056:	/* Trim comments. */
        5: 1057:	if ( ( cp = strchr( line, '#' ) ) != (char*) 0 )
    #####: 1058:	    *cp = '\0';
        -: 1059:
        -: 1060:	/* Skip leading whitespace. */
        5: 1061:	cp = line;
        5: 1062:	cp += strspn( cp, " \t\n\r" );
        -: 1063:
        -: 1064:	/* Split line into words. */
       15: 1065:	while ( *cp != '\0' )
        -: 1066:	    {
        -: 1067:	    /* Find next whitespace. */
        5: 1068:	    cp2 = cp + strcspn( cp, " \t\n\r" );
        -: 1069:	    /* Insert EOS and advance next-word pointer. */
       15: 1070:	    while ( *cp2 == ' ' || *cp2 == '\t' || *cp2 == '\n' || *cp2 == '\r' )
        5: 1071:		*cp2++ = '\0';
        -: 1072:	    /* Split into name and value. */
        5: 1073:	    name = cp;
        5: 1074:	    value = strchr( name, '=' );
        5: 1075:	    if ( value != (char*) 0 )
        4: 1076:		*value++ = '\0';
        -: 1077:	    /* Interpret. */
        5: 1078:	    if ( strcasecmp( name, "debug" ) == 0 )
        -: 1079:		{
    #####: 1080:		no_value_required( name, value );
    #####: 1081:		debug = 1;
        -: 1082:		}
        5: 1083:	    else if ( strcasecmp( name, "port" ) == 0 )
        -: 1084:		{
    #####: 1085:		value_required( name, value );
    #####: 1086:		port = (unsigned short) atoi( value );
        -: 1087:		}
        5: 1088:	    else if ( strcasecmp( name, "dir" ) == 0 )
        -: 1089:		{
        1: 1090:		value_required( name, value );
        1: 1091:		dir = e_strdup( value );
        -: 1092:		}
        4: 1093:	    else if ( strcasecmp( name, "chroot" ) == 0 )
        -: 1094:		{
        1: 1095:		no_value_required( name, value );
        1: 1096:		do_chroot = 1;
        1: 1097:		no_symlink_check = 1;
        -: 1098:		}
        3: 1099:	    else if ( strcasecmp( name, "nochroot" ) == 0 )
        -: 1100:		{
    #####: 1101:		no_value_required( name, value );
    #####: 1102:		do_chroot = 0;
    #####: 1103:		no_symlink_check = 0;
        -: 1104:		}
        3: 1105:	    else if ( strcasecmp( name, "data_dir" ) == 0 )
        -: 1106:		{
    #####: 1107:		value_required( name, value );
    #####: 1108:		data_dir = e_strdup( value );
        -: 1109:		}
        3: 1110:	    else if ( strcasecmp( name, "nosymlinkcheck" ) == 0 )
        -: 1111:		{
    #####: 1112:		no_value_required( name, value );
    #####: 1113:		no_symlink_check = 1;
        -: 1114:		}
        3: 1115:	    else if ( strcasecmp( name, "symlinkcheck" ) == 0 )
        -: 1116:		{
    #####: 1117:		no_value_required( name, value );
    #####: 1118:		no_symlink_check = 0;
        -: 1119:		}
        3: 1120:	    else if ( strcasecmp( name, "user" ) == 0 )
        -: 1121:		{
    #####: 1122:		value_required( name, value );
    #####: 1123:		user = e_strdup( value );
        -: 1124:		}
        3: 1125:	    else if ( strcasecmp( name, "cgipat" ) == 0 )
        -: 1126:		{
        1: 1127:		value_required( name, value );
        1: 1128:		cgi_pattern = e_strdup( value );
        -: 1129:		}
        2: 1130:	    else if ( strcasecmp( name, "cgilimit" ) == 0 )
        -: 1131:		{
    #####: 1132:		value_required( name, value );
    #####: 1133:		cgi_limit = atoi( value );
        -: 1134:		}
        2: 1135:	    else if ( strcasecmp( name, "urlpat" ) == 0 )
        -: 1136:		{
    #####: 1137:		value_required( name, value );
    #####: 1138:		url_pattern = e_strdup( value );
        -: 1139:		}
        4: 1140:	    else if ( strcasecmp( name, "noemptyreferers" ) == 0 ||
        2: 1141:	              strcasecmp( name, "noemptyreferrers" ) == 0 )
        -: 1142:		{
    #####: 1143:		no_value_required( name, value );
    #####: 1144:		no_empty_referrers = 1;
        -: 1145:		}
        2: 1146:	    else if ( strcasecmp( name, "localpat" ) == 0 )
        -: 1147:		{
    #####: 1148:		value_required( name, value );
    #####: 1149:		local_pattern = e_strdup( value );
        -: 1150:		}
        2: 1151:	    else if ( strcasecmp( name, "throttles" ) == 0 )
        -: 1152:		{
    #####: 1153:		value_required( name, value );
    #####: 1154:		throttlefile = e_strdup( value );
        -: 1155:		}
        2: 1156:	    else if ( strcasecmp( name, "host" ) == 0 )
        -: 1157:		{
    #####: 1158:		value_required( name, value );
    #####: 1159:		hostname = e_strdup( value );
        -: 1160:		}
        2: 1161:	    else if ( strcasecmp( name, "logfile" ) == 0 )
        -: 1162:		{
        1: 1163:		value_required( name, value );
        1: 1164:		logfile = e_strdup( value );
        -: 1165:		}
        1: 1166:	    else if ( strcasecmp( name, "vhost" ) == 0 )
        -: 1167:		{
    #####: 1168:		no_value_required( name, value );
    #####: 1169:		do_vhost = 1;
        -: 1170:		}
        1: 1171:	    else if ( strcasecmp( name, "novhost" ) == 0 )
        -: 1172:		{
    #####: 1173:		no_value_required( name, value );
    #####: 1174:		do_vhost = 0;
        -: 1175:		}
        1: 1176:	    else if ( strcasecmp( name, "globalpasswd" ) == 0 )
        -: 1177:		{
    #####: 1178:		no_value_required( name, value );
    #####: 1179:		do_global_passwd = 1;
        -: 1180:		}
        1: 1181:	    else if ( strcasecmp( name, "noglobalpasswd" ) == 0 )
        -: 1182:		{
    #####: 1183:		no_value_required( name, value );
    #####: 1184:		do_global_passwd = 0;
        -: 1185:		}
        1: 1186:	    else if ( strcasecmp( name, "pidfile" ) == 0 )
        -: 1187:		{
        1: 1188:		value_required( name, value );
        1: 1189:		pidfile = e_strdup( value );
        -: 1190:		}
    #####: 1191:	    else if ( strcasecmp( name, "charset" ) == 0 )
        -: 1192:		{
    #####: 1193:		value_required( name, value );
    #####: 1194:		charset = e_strdup( value );
        -: 1195:		}
    #####: 1196:	    else if ( strcasecmp( name, "p3p" ) == 0 )
        -: 1197:		{
    #####: 1198:		value_required( name, value );
    #####: 1199:		p3p = e_strdup( value );
        -: 1200:		}
    #####: 1201:	    else if ( strcasecmp( name, "max_age" ) == 0 )
        -: 1202:		{
    #####: 1203:		value_required( name, value );
    #####: 1204:		max_age = atoi( value );
        -: 1205:		}
        -: 1206:	    else
        -: 1207:		{
    #####: 1208:		(void) fprintf(
        -: 1209:		    stderr, "%s: unknown config option '%s'\n", argv0, name );
    #####: 1210:		exit( 1 );
        -: 1211:		}
        -: 1212:
        -: 1213:	    /* Advance to next word. */
        5: 1214:	    cp = cp2;
        5: 1215:	    cp += strspn( cp, " \t\n\r" );
        -: 1216:	    }
        -: 1217:	}
        -: 1218:
        1: 1219:    (void) fclose( fp );
        1: 1220:    }
        -: 1221:
        -: 1222:
        -: 1223:static void
        4: 1224:value_required( char* name, char* value )
        -: 1225:    {
        4: 1226:    if ( value == (char*) 0 )
        -: 1227:	{
    #####: 1228:	(void) fprintf(
        -: 1229:	    stderr, "%s: value required for %s option\n", argv0, name );
    #####: 1230:	exit( 1 );
        -: 1231:	}
        4: 1232:    }
        -: 1233:
        -: 1234:
        -: 1235:static void
        1: 1236:no_value_required( char* name, char* value )
        -: 1237:    {
        1: 1238:    if ( value != (char*) 0 )
        -: 1239:	{
    #####: 1240:	(void) fprintf(
        -: 1241:	    stderr, "%s: no value required for %s option\n",
        -: 1242:	    argv0, name );
    #####: 1243:	exit( 1 );
        -: 1244:	}
        1: 1245:    }
        -: 1246:
        -: 1247:
        -: 1248:static char*
        4: 1249:e_strdup( char* oldstr )
        -: 1250:    {
        -: 1251:    char* newstr;
        -: 1252:
        4: 1253:    newstr = strdup( oldstr );
        4: 1254:    if ( newstr == (char*) 0 )
        -: 1255:	{
    #####: 1256:	syslog( LOG_CRIT, "out of memory copying a string" );
    #####: 1257:	(void) fprintf( stderr, "%s: out of memory copying a string\n", argv0 );
    #####: 1258:	exit( 1 );
        -: 1259:	}
        4: 1260:    return newstr;
        -: 1261:    }
        -: 1262:
        -: 1263:
        -: 1264:static void
        1: 1265:lookup_hostname( httpd_sockaddr* sa4P, size_t sa4_len, int* gotv4P, httpd_sockaddr* sa6P, size_t sa6_len, int* gotv6P )
        -: 1266:    {
        -: 1267:#ifdef USE_IPV6
        -: 1268:
        -: 1269:    struct addrinfo hints;
        -: 1270:    char portstr[10];
        -: 1271:    int gaierr;
        -: 1272:    struct addrinfo* ai;
        -: 1273:    struct addrinfo* ai2;
        -: 1274:    struct addrinfo* aiv6;
        -: 1275:    struct addrinfo* aiv4;
        -: 1276:
        1: 1277:    (void) memset( &hints, 0, sizeof(hints) );
        1: 1278:    hints.ai_family = PF_UNSPEC;
        1: 1279:    hints.ai_flags = AI_PASSIVE;
        1: 1280:    hints.ai_socktype = SOCK_STREAM;
        1: 1281:    (void) snprintf( portstr, sizeof(portstr), "%d", (int) port );
        1: 1282:    if ( (gaierr = getaddrinfo( hostname, portstr, &hints, &ai )) != 0 )
        -: 1283:	{
    #####: 1284:	syslog(
        -: 1285:	    LOG_CRIT, "getaddrinfo %.80s - %.80s",
        -: 1286:	    hostname, gai_strerror( gaierr ) );
    #####: 1287:	(void) fprintf(
        -: 1288:	    stderr, "%s: getaddrinfo %s - %s\n",
        -: 1289:	    argv0, hostname, gai_strerror( gaierr ) );
    #####: 1290:	exit( 1 );
        -: 1291:	}
        -: 1292:
        -: 1293:    /* Find the first IPv6 and IPv4 entries. */
        1: 1294:    aiv6 = (struct addrinfo*) 0;
        1: 1295:    aiv4 = (struct addrinfo*) 0;
        3: 1296:    for ( ai2 = ai; ai2 != (struct addrinfo*) 0; ai2 = ai2->ai_next )
        -: 1297:	{
        2: 1298:	switch ( ai2->ai_family )
        -: 1299:	    {
        -: 1300:	    case AF_INET6:
        1: 1301:	    if ( aiv6 == (struct addrinfo*) 0 )
        1: 1302:		aiv6 = ai2;
        1: 1303:	    break;
        -: 1304:	    case AF_INET:
        1: 1305:	    if ( aiv4 == (struct addrinfo*) 0 )
        1: 1306:		aiv4 = ai2;
        1: 1307:	    break;
        -: 1308:	    }
        -: 1309:	}
        -: 1310:
        1: 1311:    if ( aiv6 == (struct addrinfo*) 0 )
    #####: 1312:	*gotv6P = 0;
        -: 1313:    else
        -: 1314:	{
        1: 1315:	if ( sa6_len < aiv6->ai_addrlen )
        -: 1316:	    {
    #####: 1317:	    syslog(
        -: 1318:		LOG_CRIT, "%.80s - sockaddr too small (%lu < %lu)",
        -: 1319:		hostname, (unsigned long) sa6_len,
    #####: 1320:		(unsigned long) aiv6->ai_addrlen );
    #####: 1321:	    exit( 1 );
        -: 1322:	    }
        1: 1323:	(void) memset( sa6P, 0, sa6_len );
        1: 1324:	(void) memmove( sa6P, aiv6->ai_addr, aiv6->ai_addrlen );
        1: 1325:	*gotv6P = 1;
        -: 1326:	}
        -: 1327:
        1: 1328:    if ( aiv4 == (struct addrinfo*) 0 )
    #####: 1329:	*gotv4P = 0;
        -: 1330:    else
        -: 1331:	{
        1: 1332:	if ( sa4_len < aiv4->ai_addrlen )
        -: 1333:	    {
    #####: 1334:	    syslog(
        -: 1335:		LOG_CRIT, "%.80s - sockaddr too small (%lu < %lu)",
        -: 1336:		hostname, (unsigned long) sa4_len,
    #####: 1337:		(unsigned long) aiv4->ai_addrlen );
    #####: 1338:	    exit( 1 );
        -: 1339:	    }
        1: 1340:	(void) memset( sa4P, 0, sa4_len );
        1: 1341:	(void) memmove( sa4P, aiv4->ai_addr, aiv4->ai_addrlen );
        1: 1342:	*gotv4P = 1;
        -: 1343:	}
        -: 1344:
        1: 1345:    freeaddrinfo( ai );
        -: 1346:
        -: 1347:#else /* USE_IPV6 */
        -: 1348:
        -: 1349:    struct hostent* he;
        -: 1350:
        -: 1351:    *gotv6P = 0;
        -: 1352:
        -: 1353:    (void) memset( sa4P, 0, sa4_len );
        -: 1354:    sa4P->sa.sa_family = AF_INET;
        -: 1355:    if ( hostname == (char*) 0 )
        -: 1356:	sa4P->sa_in.sin_addr.s_addr = htonl( INADDR_ANY );
        -: 1357:    else
        -: 1358:	{
        -: 1359:	sa4P->sa_in.sin_addr.s_addr = inet_addr( hostname );
        -: 1360:	if ( (int) sa4P->sa_in.sin_addr.s_addr == -1 )
        -: 1361:	    {
        -: 1362:	    he = gethostbyname( hostname );
        -: 1363:	    if ( he == (struct hostent*) 0 )
        -: 1364:		{
        -: 1365:#ifdef HAVE_HSTRERROR
        -: 1366:		syslog(
        -: 1367:		    LOG_CRIT, "gethostbyname %.80s - %.80s",
        -: 1368:		    hostname, hstrerror( h_errno ) );
        -: 1369:		(void) fprintf(
        -: 1370:		    stderr, "%s: gethostbyname %s - %s\n",
        -: 1371:		    argv0, hostname, hstrerror( h_errno ) );
        -: 1372:#else /* HAVE_HSTRERROR */
        -: 1373:		syslog( LOG_CRIT, "gethostbyname %.80s failed", hostname );
        -: 1374:		(void) fprintf(
        -: 1375:		    stderr, "%s: gethostbyname %s failed\n", argv0, hostname );
        -: 1376:#endif /* HAVE_HSTRERROR */
        -: 1377:		exit( 1 );
        -: 1378:		}
        -: 1379:	    if ( he->h_addrtype != AF_INET )
        -: 1380:		{
        -: 1381:		syslog( LOG_CRIT, "%.80s - non-IP network address", hostname );
        -: 1382:		(void) fprintf(
        -: 1383:		    stderr, "%s: %s - non-IP network address\n",
        -: 1384:		    argv0, hostname );
        -: 1385:		exit( 1 );
        -: 1386:		}
        -: 1387:	    (void) memmove(
        -: 1388:		&sa4P->sa_in.sin_addr.s_addr, he->h_addr, he->h_length );
        -: 1389:	    }
        -: 1390:	}
        -: 1391:    sa4P->sa_in.sin_port = htons( port );
        -: 1392:    *gotv4P = 1;
        -: 1393:
        -: 1394:#endif /* USE_IPV6 */
        1: 1395:    }
        -: 1396:
        -: 1397:
        -: 1398:static void
    #####: 1399:read_throttlefile( char* tf )
        -: 1400:    {
        -: 1401:    FILE* fp;
        -: 1402:    char buf[5000];
        -: 1403:    char* cp;
        -: 1404:    int len;
        -: 1405:    char pattern[5000];
        -: 1406:    long max_limit, min_limit;
        -: 1407:    struct timeval tv;
        -: 1408:
    #####: 1409:    fp = fopen( tf, "r" );
    #####: 1410:    if ( fp == (FILE*) 0 )
        -: 1411:	{
    #####: 1412:	syslog( LOG_CRIT, "%.80s - %m", tf );
    #####: 1413:	perror( tf );
    #####: 1414:	exit( 1 );
        -: 1415:	}
        -: 1416:
    #####: 1417:    (void) gettimeofday( &tv, (struct timezone*) 0 );
        -: 1418:
    #####: 1419:    while ( fgets( buf, sizeof(buf), fp ) != (char*) 0 )
        -: 1420:	{
        -: 1421:	/* Nuke comments. */
    #####: 1422:	cp = strchr( buf, '#' );
    #####: 1423:	if ( cp != (char*) 0 )
    #####: 1424:	    *cp = '\0';
        -: 1425:
        -: 1426:	/* Nuke trailing whitespace. */
    #####: 1427:	len = strlen( buf );
    #####: 1428:	while ( len > 0 &&
    #####: 1429:		( buf[len-1] == ' ' || buf[len-1] == '\t' ||
    #####: 1430:		  buf[len-1] == '\n' || buf[len-1] == '\r' ) )
    #####: 1431:	    buf[--len] = '\0';
        -: 1432:
        -: 1433:	/* Ignore empty lines. */
    #####: 1434:	if ( len == 0 )
    #####: 1435:	    continue;
        -: 1436:
        -: 1437:	/* Parse line. */
    #####: 1438:	if ( sscanf( buf, " %4900[^ \t] %ld-%ld", pattern, &min_limit, &max_limit ) == 3 )
        -: 1439:	    {}
    #####: 1440:	else if ( sscanf( buf, " %4900[^ \t] %ld", pattern, &max_limit ) == 2 )
    #####: 1441:	    min_limit = 0;
        -: 1442:	else
        -: 1443:	    {
    #####: 1444:	    syslog( LOG_CRIT,
        -: 1445:		"unparsable line in %.80s - %.80s", tf, buf );
    #####: 1446:	    (void) fprintf( stderr,
        -: 1447:		"%s: unparsable line in %.80s - %.80s\n",
        -: 1448:		argv0, tf, buf );
    #####: 1449:	    continue;
        -: 1450:	    }
        -: 1451:
        -: 1452:	/* Nuke any leading slashes in pattern. */
    #####: 1453:	if ( pattern[0] == '/' )
    #####: 1454:	    (void) ol_strcpy( pattern, &pattern[1] );
    #####: 1455:	while ( ( cp = strstr( pattern, "|/" ) ) != (char*) 0 )
    #####: 1456:	    (void) ol_strcpy( cp + 1, cp + 2 );
        -: 1457:
        -: 1458:	/* Check for room in throttles. */
    #####: 1459:	if ( numthrottles >= maxthrottles )
        -: 1460:	    {
    #####: 1461:	    if ( maxthrottles == 0 )
        -: 1462:		{
    #####: 1463:		maxthrottles = 100;     /* arbitrary */
    #####: 1464:		throttles = NEW( throttletab, maxthrottles );
        -: 1465:		}
        -: 1466:	    else
        -: 1467:		{
    #####: 1468:		maxthrottles *= 2;
    #####: 1469:		throttles = RENEW( throttles, throttletab, maxthrottles );
        -: 1470:		}
    #####: 1471:	    if ( throttles == (throttletab*) 0 )
        -: 1472:		{
    #####: 1473:		syslog( LOG_CRIT, "out of memory allocating a throttletab" );
    #####: 1474:		(void) fprintf(
        -: 1475:		    stderr, "%s: out of memory allocating a throttletab\n",
        -: 1476:		    argv0 );
    #####: 1477:		exit( 1 );
        -: 1478:		}
        -: 1479:	    }
        -: 1480:
        -: 1481:	/* Add to table. */
    #####: 1482:	throttles[numthrottles].pattern = e_strdup( pattern );
    #####: 1483:	throttles[numthrottles].max_limit = max_limit;
    #####: 1484:	throttles[numthrottles].min_limit = min_limit;
    #####: 1485:	throttles[numthrottles].rate = 0;
    #####: 1486:	throttles[numthrottles].bytes_since_avg = 0;
    #####: 1487:	throttles[numthrottles].num_sending = 0;
        -: 1488:
    #####: 1489:	++numthrottles;
        -: 1490:	}
    #####: 1491:    (void) fclose( fp );
    #####: 1492:    }
        -: 1493:
        -: 1494:
        -: 1495:static void
    #####: 1496:shut_down( void )
        -: 1497:    {
        -: 1498:    int cnum;
        -: 1499:    struct timeval tv;
        -: 1500:
    #####: 1501:    (void) gettimeofday( &tv, (struct timezone*) 0 );
    #####: 1502:    logstats( &tv );
    #####: 1503:    for ( cnum = 0; cnum < max_connects; ++cnum )
        -: 1504:	{
    #####: 1505:	if ( connects[cnum].conn_state != CNST_FREE )
    #####: 1506:	    httpd_close_conn( connects[cnum].hc, &tv );
    #####: 1507:	if ( connects[cnum].hc != (httpd_conn*) 0 )
        -: 1508:	    {
    #####: 1509:	    httpd_destroy_conn( connects[cnum].hc );
    #####: 1510:	    free( (void*) connects[cnum].hc );
    #####: 1511:	    --httpd_conn_count;
    #####: 1512:	    connects[cnum].hc = (httpd_conn*) 0;
        -: 1513:	    }
        -: 1514:	}
    #####: 1515:    if ( hs != (httpd_server*) 0 )
        -: 1516:	{
    #####: 1517:	httpd_server* ths = hs;
    #####: 1518:	hs = (httpd_server*) 0;
    #####: 1519:	if ( ths->listen4_fd != -1 )
    #####: 1520:	    fdwatch_del_fd( ths->listen4_fd );
    #####: 1521:	if ( ths->listen6_fd != -1 )
    #####: 1522:	    fdwatch_del_fd( ths->listen6_fd );
    #####: 1523:	httpd_terminate( ths );
        -: 1524:	}
    #####: 1525:    mmc_term();
    #####: 1526:    tmr_term();
    #####: 1527:    free( (void*) connects );
    #####: 1528:    if ( throttles != (throttletab*) 0 )
    #####: 1529:	free( (void*) throttles );
    #####: 1530:    }
        -: 1531:
        -: 1532:
        -: 1533:static int
    #####: 1534:handle_newconnect( struct timeval* tvP, int listen_fd )
        -: 1535:    {
        -: 1536:    connecttab* c;
        -: 1537:    ClientData client_data;
        -: 1538:
        -: 1539:    /* This loops until the accept() fails, trying to start new
        -: 1540:    ** connections as fast as possible so we don't overrun the
        -: 1541:    ** listen queue.
        -: 1542:    */
        -: 1543:    for (;;)
        -: 1544:	{
        -: 1545:	/* Is there room in the connection table? */
    #####: 1546:	if ( num_connects >= max_connects )
        -: 1547:	    {
        -: 1548:	    /* Out of connection slots.  Run the timers, then the
        -: 1549:	    ** existing connections, and maybe we'll free up a slot
        -: 1550:	    ** by the time we get back here.
        -: 1551:	    */
    #####: 1552:	    syslog( LOG_WARNING, "too many connections!" );
    #####: 1553:	    tmr_run( tvP );
    #####: 1554:	    return 0;
        -: 1555:	    }
        -: 1556:	/* Get the first free connection entry off the free list. */
    #####: 1557:	if ( first_free_connect == -1 || connects[first_free_connect].conn_state != CNST_FREE )
        -: 1558:	    {
    #####: 1559:	    syslog( LOG_CRIT, "the connects free list is messed up" );
    #####: 1560:	    exit( 1 );
        -: 1561:	    }
    #####: 1562:	c = &connects[first_free_connect];
        -: 1563:	/* Make the httpd_conn if necessary. */
    #####: 1564:	if ( c->hc == (httpd_conn*) 0 )
        -: 1565:	    {
    #####: 1566:	    c->hc = NEW( httpd_conn, 1 );
    #####: 1567:	    if ( c->hc == (httpd_conn*) 0 )
        -: 1568:		{
    #####: 1569:		syslog( LOG_CRIT, "out of memory allocating an httpd_conn" );
    #####: 1570:		exit( 1 );
        -: 1571:		}
    #####: 1572:	    c->hc->initialized = 0;
    #####: 1573:	    ++httpd_conn_count;
        -: 1574:	    }
        -: 1575:
        -: 1576:	/* Get the connection. */
    #####: 1577:	switch ( httpd_get_conn( hs, listen_fd, c->hc ) )
        -: 1578:	    {
        -: 1579:	    /* Some error happened.  Run the timers, then the
        -: 1580:	    ** existing connections.  Maybe the error will clear.
        -: 1581:	    */
        -: 1582:	    case GC_FAIL:
    #####: 1583:	    tmr_run( tvP );
    #####: 1584:	    return 0;
        -: 1585:
        -: 1586:	    /* No more connections to accept for now. */
        -: 1587:	    case GC_NO_MORE:
    #####: 1588:	    return 1;
        -: 1589:	    }
    #####: 1590:	c->conn_state = CNST_READING;
        -: 1591:	/* Pop it off the free list. */
    #####: 1592:	first_free_connect = c->next_free_connect;
    #####: 1593:	c->next_free_connect = -1;
    #####: 1594:	++num_connects;
    #####: 1595:	client_data.p = c;
    #####: 1596:	c->active_at = tvP->tv_sec;
    #####: 1597:	c->wakeup_timer = (Timer*) 0;
    #####: 1598:	c->linger_timer = (Timer*) 0;
    #####: 1599:	c->next_byte_index = 0;
    #####: 1600:	c->numtnums = 0;
        -: 1601:
        -: 1602:	/* Set the connection file descriptor to no-delay mode. */
    #####: 1603:	httpd_set_ndelay( c->hc->conn_fd );
        -: 1604:
    #####: 1605:	fdwatch_add_fd( c->hc->conn_fd, c, FDW_READ );
        -: 1606:
    #####: 1607:	++stats_connections;
    #####: 1608:	if ( num_connects > stats_simultaneous )
    #####: 1609:	    stats_simultaneous = num_connects;
    #####: 1610:	}
        -: 1611:    }
        -: 1612:
        -: 1613:
        -: 1614:static void
    #####: 1615:handle_read( connecttab* c, struct timeval* tvP )
        -: 1616:    {
        -: 1617:    int sz;
        -: 1618:    ClientData client_data;
    #####: 1619:    httpd_conn* hc = c->hc;
        -: 1620:
        -: 1621:    /* Is there room in our buffer to read more bytes? */
    #####: 1622:    if ( hc->read_idx >= hc->read_size )
        -: 1623:	{
    #####: 1624:	if ( hc->read_size > 5000 )
        -: 1625:	    {
    #####: 1626:	    httpd_send_err( hc, 400, httpd_err400title, "", httpd_err400form, "" );
    #####: 1627:	    finish_connection( c, tvP );
    #####: 1628:	    return;
        -: 1629:	    }
    #####: 1630:	httpd_realloc_str(
    #####: 1631:	    &hc->read_buf, &hc->read_size, hc->read_size + 1000 );
        -: 1632:	}
        -: 1633:
        -: 1634:    /* Read some more bytes. */
    #####: 1635:    sz = read(
    #####: 1636:	hc->conn_fd, &(hc->read_buf[hc->read_idx]),
    #####: 1637:	hc->read_size - hc->read_idx );
    #####: 1638:    if ( sz == 0 )
        -: 1639:	{
    #####: 1640:	httpd_send_err( hc, 400, httpd_err400title, "", httpd_err400form, "" );
    #####: 1641:	finish_connection( c, tvP );
    #####: 1642:	return;
        -: 1643:	}
    #####: 1644:    if ( sz < 0 )
        -: 1645:	{
        -: 1646:	/* Ignore EINTR and EAGAIN.  Also ignore EWOULDBLOCK.  At first glance
        -: 1647:	** you would think that connections returned by fdwatch as readable
        -: 1648:	** should never give an EWOULDBLOCK; however, this apparently can
        -: 1649:	** happen if a packet gets garbled.
        -: 1650:	*/
    #####: 1651:	if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK )
    #####: 1652:	    return;
    #####: 1653:	httpd_send_err(
        -: 1654:	    hc, 400, httpd_err400title, "", httpd_err400form, "" );
    #####: 1655:	finish_connection( c, tvP );
    #####: 1656:	return;
        -: 1657:	}
    #####: 1658:    hc->read_idx += sz;
    #####: 1659:    c->active_at = tvP->tv_sec;
        -: 1660:
        -: 1661:    /* Do we have a complete request yet? */
    #####: 1662:    switch ( httpd_got_request( hc ) )
        -: 1663:	{
        -: 1664:	case GR_NO_REQUEST:
    #####: 1665:	return;
        -: 1666:	case GR_BAD_REQUEST:
    #####: 1667:	httpd_send_err( hc, 400, httpd_err400title, "", httpd_err400form, "" );
    #####: 1668:	finish_connection( c, tvP );
    #####: 1669:	return;
        -: 1670:	}
        -: 1671:
        -: 1672:    /* Yes.  Try parsing and resolving it. */
    #####: 1673:    if ( httpd_parse_request( hc ) < 0 )
        -: 1674:	{
    #####: 1675:	finish_connection( c, tvP );
    #####: 1676:	return;
        -: 1677:	}
        -: 1678:
        -: 1679:    /* Check the throttle table */
    #####: 1680:    if ( ! check_throttles( c ) )
        -: 1681:	{
    #####: 1682:	httpd_send_err(
        -: 1683:	    hc, 503, httpd_err503title, "", httpd_err503form, hc->encodedurl );
    #####: 1684:	finish_connection( c, tvP );
    #####: 1685:	return;
        -: 1686:	}
        -: 1687:
        -: 1688:    /* Start the connection going. */
    #####: 1689:    if ( httpd_start_request( hc, tvP ) < 0 )
        -: 1690:	{
        -: 1691:	/* Something went wrong.  Close down the connection. */
    #####: 1692:	finish_connection( c, tvP );
    #####: 1693:	return;
        -: 1694:	}
        -: 1695:
        -: 1696:    /* Fill in end_byte_index. */
    #####: 1697:    if ( hc->got_range )
        -: 1698:	{
    #####: 1699:	c->next_byte_index = hc->first_byte_index;
    #####: 1700:	c->end_byte_index = hc->last_byte_index + 1;
        -: 1701:	}
    #####: 1702:    else if ( hc->bytes_to_send < 0 )
    #####: 1703:	c->end_byte_index = 0;
        -: 1704:    else
    #####: 1705:	c->end_byte_index = hc->bytes_to_send;
        -: 1706:
        -: 1707:    /* Check if it's already handled. */
    #####: 1708:    if ( hc->file_address == (char*) 0 )
        -: 1709:	{
        -: 1710:	/* No file address means someone else is handling it. */
        -: 1711:	int tind;
    #####: 1712:	for ( tind = 0; tind < c->numtnums; ++tind )
    #####: 1713:	    throttles[c->tnums[tind]].bytes_since_avg += hc->bytes_sent;
    #####: 1714:	c->next_byte_index = hc->bytes_sent;
    #####: 1715:	finish_connection( c, tvP );
    #####: 1716:	return;
        -: 1717:	}
    #####: 1718:    if ( c->next_byte_index >= c->end_byte_index )
        -: 1719:	{
        -: 1720:	/* There's nothing to send. */
    #####: 1721:	finish_connection( c, tvP );
    #####: 1722:	return;
        -: 1723:	}
        -: 1724:
        -: 1725:    /* Cool, we have a valid connection and a file to send to it. */
    #####: 1726:    c->conn_state = CNST_SENDING;
    #####: 1727:    c->started_at = tvP->tv_sec;
    #####: 1728:    c->wouldblock_delay = 0;
    #####: 1729:    client_data.p = c;
        -: 1730:
    #####: 1731:    fdwatch_del_fd( hc->conn_fd );
    #####: 1732:    fdwatch_add_fd( hc->conn_fd, c, FDW_WRITE );
        -: 1733:    }
        -: 1734:
        -: 1735:
        -: 1736:static void
    #####: 1737:handle_send( connecttab* c, struct timeval* tvP )
        -: 1738:    {
        -: 1739:    size_t max_bytes;
        -: 1740:    int sz, coast;
        -: 1741:    ClientData client_data;
        -: 1742:    time_t elapsed;
    #####: 1743:    httpd_conn* hc = c->hc;
        -: 1744:    int tind;
        -: 1745:
    #####: 1746:    if ( c->max_limit == THROTTLE_NOLIMIT )
    #####: 1747:	max_bytes = 1000000000L;
        -: 1748:    else
    #####: 1749:	max_bytes = c->max_limit / 4;	/* send at most 1/4 seconds worth */
        -: 1750:
        -: 1751:    /* Do we need to write the headers first? */
    #####: 1752:    if ( hc->responselen == 0 )
        -: 1753:	{
        -: 1754:	/* No, just write the file. */
    #####: 1755:	sz = write(
    #####: 1756:	    hc->conn_fd, &(hc->file_address[c->next_byte_index]),
    #####: 1757:	    MIN( c->end_byte_index - c->next_byte_index, max_bytes ) );
        -: 1758:	}
        -: 1759:    else
        -: 1760:	{
        -: 1761:	/* Yes.  We'll combine headers and file into a single writev(),
        -: 1762:	** hoping that this generates a single packet.
        -: 1763:	*/
        -: 1764:	struct iovec iv[2];
        -: 1765:
    #####: 1766:	iv[0].iov_base = hc->response;
    #####: 1767:	iv[0].iov_len = hc->responselen;
    #####: 1768:	iv[1].iov_base = &(hc->file_address[c->next_byte_index]);
    #####: 1769:	iv[1].iov_len = MIN( c->end_byte_index - c->next_byte_index, max_bytes );
    #####: 1770:	sz = writev( hc->conn_fd, iv, 2 );
        -: 1771:	}
        -: 1772:
    #####: 1773:    if ( sz < 0 && errno == EINTR )
    #####: 1774:	return;
        -: 1775:
    #####: 1776:    if ( sz == 0 ||
    #####: 1777:	 ( sz < 0 && ( errno == EWOULDBLOCK || errno == EAGAIN ) ) )
        -: 1778:	{
        -: 1779:	/* This shouldn't happen, but some kernels, e.g.
        -: 1780:	** SunOS 4.1.x, are broken and select() says that
        -: 1781:	** O_NDELAY sockets are always writable even when
        -: 1782:	** they're actually not.
        -: 1783:	**
        -: 1784:	** Current workaround is to block sending on this
        -: 1785:	** socket for a brief adaptively-tuned period.
        -: 1786:	** Fortunately we already have all the necessary
        -: 1787:	** blocking code, for use with throttling.
        -: 1788:	*/
    #####: 1789:	c->wouldblock_delay += MIN_WOULDBLOCK_DELAY;
    #####: 1790:	c->conn_state = CNST_PAUSING;
    #####: 1791:	fdwatch_del_fd( hc->conn_fd );
    #####: 1792:	client_data.p = c;
    #####: 1793:	if ( c->wakeup_timer != (Timer*) 0 )
    #####: 1794:	    syslog( LOG_ERR, "replacing non-null wakeup_timer!" );
    #####: 1795:	c->wakeup_timer = tmr_create(
        -: 1796:	    tvP, wakeup_connection, client_data, c->wouldblock_delay, 0 );
    #####: 1797:	if ( c->wakeup_timer == (Timer*) 0 )
        -: 1798:	    {
    #####: 1799:	    syslog( LOG_CRIT, "tmr_create(wakeup_connection) failed" );
    #####: 1800:	    exit( 1 );
        -: 1801:	    }
    #####: 1802:	return;
        -: 1803:	}
        -: 1804:
    #####: 1805:    if ( sz < 0 )
        -: 1806:	{
        -: 1807:	/* Something went wrong, close this connection.
        -: 1808:	**
        -: 1809:	** If it's just an EPIPE, don't bother logging, that
        -: 1810:	** just means the client hung up on us.
        -: 1811:	**
        -: 1812:	** On some systems, write() occasionally gives an EINVAL.
        -: 1813:	** Dunno why, something to do with the socket going
        -: 1814:	** bad.  Anyway, we don't log those either.
        -: 1815:	**
        -: 1816:	** And ECONNRESET isn't interesting either.
        -: 1817:	*/
    #####: 1818:	if ( errno != EPIPE && errno != EINVAL && errno != ECONNRESET )
    #####: 1819:	    syslog( LOG_ERR, "write - %m sending %.80s", hc->encodedurl );
    #####: 1820:	clear_connection( c, tvP );
    #####: 1821:	return;
        -: 1822:	}
        -: 1823:
        -: 1824:    /* Ok, we wrote something. */
    #####: 1825:    c->active_at = tvP->tv_sec;
        -: 1826:    /* Was this a headers + file writev()? */
    #####: 1827:    if ( hc->responselen > 0 )
        -: 1828:	{
        -: 1829:	/* Yes; did we write only part of the headers? */
    #####: 1830:	if ( sz < hc->responselen )
        -: 1831:	    {
        -: 1832:	    /* Yes; move the unwritten part to the front of the buffer. */
    #####: 1833:	    int newlen = hc->responselen - sz;
    #####: 1834:	    (void) memmove( hc->response, &(hc->response[sz]), newlen );
    #####: 1835:	    hc->responselen = newlen;
    #####: 1836:	    sz = 0;
        -: 1837:	    }
        -: 1838:	else
        -: 1839:	    {
        -: 1840:	    /* Nope, we wrote the full headers, so adjust accordingly. */
    #####: 1841:	    sz -= hc->responselen;
    #####: 1842:	    hc->responselen = 0;
        -: 1843:	    }
        -: 1844:	}
        -: 1845:    /* And update how much of the file we wrote. */
    #####: 1846:    c->next_byte_index += sz;
    #####: 1847:    c->hc->bytes_sent += sz;
    #####: 1848:    for ( tind = 0; tind < c->numtnums; ++tind )
    #####: 1849:	throttles[c->tnums[tind]].bytes_since_avg += sz;
        -: 1850:
        -: 1851:    /* Are we done? */
    #####: 1852:    if ( c->next_byte_index >= c->end_byte_index )
        -: 1853:	{
        -: 1854:	/* This connection is finished! */
    #####: 1855:	finish_connection( c, tvP );
    #####: 1856:	return;
        -: 1857:	}
        -: 1858:
        -: 1859:    /* Tune the (blockheaded) wouldblock delay. */
    #####: 1860:    if ( c->wouldblock_delay > MIN_WOULDBLOCK_DELAY )
    #####: 1861:	c->wouldblock_delay -= MIN_WOULDBLOCK_DELAY;
        -: 1862:
        -: 1863:    /* If we're throttling, check if we're sending too fast. */
    #####: 1864:    if ( c->max_limit != THROTTLE_NOLIMIT )
        -: 1865:	{
    #####: 1866:	elapsed = tvP->tv_sec - c->started_at;
    #####: 1867:	if ( elapsed == 0 )
    #####: 1868:	    elapsed = 1;	/* count at least one second */
    #####: 1869:	if ( c->hc->bytes_sent / elapsed > c->max_limit )
        -: 1870:	    {
    #####: 1871:	    c->conn_state = CNST_PAUSING;
    #####: 1872:	    fdwatch_del_fd( hc->conn_fd );
        -: 1873:	    /* How long should we wait to get back on schedule?  If less
        -: 1874:	    ** than a second (integer math rounding), use 1/2 second.
        -: 1875:	    */
    #####: 1876:	    coast = c->hc->bytes_sent / c->max_limit - elapsed;
    #####: 1877:	    client_data.p = c;
    #####: 1878:	    if ( c->wakeup_timer != (Timer*) 0 )
    #####: 1879:		syslog( LOG_ERR, "replacing non-null wakeup_timer!" );
    #####: 1880:	    c->wakeup_timer = tmr_create(
        -: 1881:		tvP, wakeup_connection, client_data,
        -: 1882:		coast > 0 ? ( coast * 1000L ) : 500L, 0 );
    #####: 1883:	    if ( c->wakeup_timer == (Timer*) 0 )
        -: 1884:		{
    #####: 1885:		syslog( LOG_CRIT, "tmr_create(wakeup_connection) failed" );
    #####: 1886:		exit( 1 );
        -: 1887:		}
        -: 1888:	    }
        -: 1889:	}
        -: 1890:    /* (No check on min_limit here, that only controls connection startups.) */
        -: 1891:    }
        -: 1892:
        -: 1893:
        -: 1894:static void
    #####: 1895:handle_linger( connecttab* c, struct timeval* tvP )
        -: 1896:    {
        -: 1897:    char buf[4096];
        -: 1898:    int r;
        -: 1899:
        -: 1900:    /* In lingering-close mode we just read and ignore bytes.  An error
        -: 1901:    ** or EOF ends things, otherwise we go until a timeout.
        -: 1902:    */
    #####: 1903:    r = read( c->hc->conn_fd, buf, sizeof(buf) );
    #####: 1904:    if ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )
    #####: 1905:	return;
    #####: 1906:    if ( r <= 0 )
    #####: 1907:	really_clear_connection( c, tvP );
        -: 1908:    }
        -: 1909:
        -: 1910:
        -: 1911:static int
    #####: 1912:check_throttles( connecttab* c )
        -: 1913:    {
        -: 1914:    int tnum;
        -: 1915:    long l;
        -: 1916:
    #####: 1917:    c->numtnums = 0;
    #####: 1918:    c->max_limit = c->min_limit = THROTTLE_NOLIMIT;
    #####: 1919:    for ( tnum = 0; tnum < numthrottles && c->numtnums < MAXTHROTTLENUMS;
    #####: 1920:	  ++tnum )
    #####: 1921:	if ( match( throttles[tnum].pattern, c->hc->expnfilename ) )
        -: 1922:	    {
        -: 1923:	    /* If we're way over the limit, don't even start. */
    #####: 1924:	    if ( throttles[tnum].rate > throttles[tnum].max_limit * 2 )
    #####: 1925:		return 0;
        -: 1926:	    /* Also don't start if we're under the minimum. */
    #####: 1927:	    if ( throttles[tnum].rate < throttles[tnum].min_limit )
    #####: 1928:		return 0;
    #####: 1929:	    if ( throttles[tnum].num_sending < 0 )
        -: 1930:		{
    #####: 1931:		syslog( LOG_ERR, "throttle sending count was negative - shouldn't happen!" );
    #####: 1932:		throttles[tnum].num_sending = 0;
        -: 1933:		}
    #####: 1934:	    c->tnums[c->numtnums++] = tnum;
    #####: 1935:	    ++throttles[tnum].num_sending;
    #####: 1936:	    l = throttles[tnum].max_limit / throttles[tnum].num_sending;
    #####: 1937:	    if ( c->max_limit == THROTTLE_NOLIMIT )
    #####: 1938:		c->max_limit = l;
        -: 1939:	    else
    #####: 1940:		c->max_limit = MIN( c->max_limit, l );
    #####: 1941:	    l = throttles[tnum].min_limit;
    #####: 1942:	    if ( c->min_limit == THROTTLE_NOLIMIT )
    #####: 1943:		c->min_limit = l;
        -: 1944:	    else
    #####: 1945:		c->min_limit = MAX( c->min_limit, l );
        -: 1946:	    }
    #####: 1947:    return 1;
        -: 1948:    }
        -: 1949:
        -: 1950:
        -: 1951:static void
    #####: 1952:clear_throttles( connecttab* c, struct timeval* tvP )
        -: 1953:    {
        -: 1954:    int tind;
        -: 1955:
    #####: 1956:    for ( tind = 0; tind < c->numtnums; ++tind )
    #####: 1957:	--throttles[c->tnums[tind]].num_sending;
    #####: 1958:    }
        -: 1959:
        -: 1960:
        -: 1961:static void
    #####: 1962:update_throttles( ClientData client_data, struct timeval* nowP )
        -: 1963:    {
        -: 1964:    int tnum, tind;
        -: 1965:    int cnum;
        -: 1966:    connecttab* c;
        -: 1967:    long l;
        -: 1968:
        -: 1969:    /* Update the average sending rate for each throttle.  This is only used
        -: 1970:    ** when new connections start up.
        -: 1971:    */
    #####: 1972:    for ( tnum = 0; tnum < numthrottles; ++tnum )
        -: 1973:	{
    #####: 1974:	throttles[tnum].rate = ( 2 * throttles[tnum].rate + throttles[tnum].bytes_since_avg / THROTTLE_TIME ) / 3;
    #####: 1975:	throttles[tnum].bytes_since_avg = 0;
        -: 1976:	/* Log a warning message if necessary. */
    #####: 1977:	if ( throttles[tnum].rate > throttles[tnum].max_limit && throttles[tnum].num_sending != 0 )
        -: 1978:	    {
    #####: 1979:	    if ( throttles[tnum].rate > throttles[tnum].max_limit * 2 )
    #####: 1980:		syslog( LOG_NOTICE, "throttle #%d '%.80s' rate %ld greatly exceeding limit %ld; %d sending", tnum, throttles[tnum].pattern, throttles[tnum].rate, throttles[tnum].max_limit, throttles[tnum].num_sending );
        -: 1981:	    else
    #####: 1982:		syslog( LOG_INFO, "throttle #%d '%.80s' rate %ld exceeding limit %ld; %d sending", tnum, throttles[tnum].pattern, throttles[tnum].rate, throttles[tnum].max_limit, throttles[tnum].num_sending );
        -: 1983:	    }
    #####: 1984:	if ( throttles[tnum].rate < throttles[tnum].min_limit && throttles[tnum].num_sending != 0 )
        -: 1985:	    {
    #####: 1986:	    syslog( LOG_NOTICE, "throttle #%d '%.80s' rate %ld lower than minimum %ld; %d sending", tnum, throttles[tnum].pattern, throttles[tnum].rate, throttles[tnum].min_limit, throttles[tnum].num_sending );
        -: 1987:	    }
        -: 1988:	}
        -: 1989:
        -: 1990:    /* Now update the sending rate on all the currently-sending connections,
        -: 1991:    ** redistributing it evenly.
        -: 1992:    */
    #####: 1993:    for ( cnum = 0; cnum < max_connects; ++cnum )
        -: 1994:	{
    #####: 1995:	c = &connects[cnum];
    #####: 1996:	if ( c->conn_state == CNST_SENDING || c->conn_state == CNST_PAUSING )
        -: 1997:	    {
    #####: 1998:	    c->max_limit = THROTTLE_NOLIMIT;
    #####: 1999:	    for ( tind = 0; tind < c->numtnums; ++tind )
        -: 2000:		{
    #####: 2001:		tnum = c->tnums[tind];
    #####: 2002:		l = throttles[tnum].max_limit / throttles[tnum].num_sending;
    #####: 2003:		if ( c->max_limit == THROTTLE_NOLIMIT )
    #####: 2004:		    c->max_limit = l;
        -: 2005:		else
    #####: 2006:		    c->max_limit = MIN( c->max_limit, l );
        -: 2007:		}
        -: 2008:	    }
        -: 2009:	}
    #####: 2010:    }
        -: 2011:
        -: 2012:
        -: 2013:static void
    #####: 2014:finish_connection( connecttab* c, struct timeval* tvP )
        -: 2015:    {
        -: 2016:    /* If we haven't actually sent the buffered response yet, do so now. */
    #####: 2017:    httpd_write_response( c->hc );
        -: 2018:
        -: 2019:    /* And clear. */
    #####: 2020:    clear_connection( c, tvP );
    #####: 2021:    }
        -: 2022:
        -: 2023:
        -: 2024:static void
    #####: 2025:clear_connection( connecttab* c, struct timeval* tvP )
        -: 2026:    {
        -: 2027:    ClientData client_data;
        -: 2028:
    #####: 2029:    if ( c->wakeup_timer != (Timer*) 0 )
        -: 2030:	{
    #####: 2031:	tmr_cancel( c->wakeup_timer );
    #####: 2032:	c->wakeup_timer = 0;
        -: 2033:	}
        -: 2034:
        -: 2035:    /* This is our version of Apache's lingering_close() routine, which is
        -: 2036:    ** their version of the often-broken SO_LINGER socket option.  For why
        -: 2037:    ** this is necessary, see http://www.apache.org/docs/misc/fin_wait_2.html
        -: 2038:    ** What we do is delay the actual closing for a few seconds, while reading
        -: 2039:    ** any bytes that come over the connection.  However, we don't want to do
        -: 2040:    ** this unless it's necessary, because it ties up a connection slot and
        -: 2041:    ** file descriptor which means our maximum connection-handling rate
        -: 2042:    ** is lower.  So, elsewhere we set a flag when we detect the few
        -: 2043:    ** circumstances that make a lingering close necessary.  If the flag
        -: 2044:    ** isn't set we do the real close now.
        -: 2045:    */
    #####: 2046:    if ( c->conn_state == CNST_LINGERING )
        -: 2047:	{
        -: 2048:	/* If we were already lingering, shut down for real. */
    #####: 2049:	tmr_cancel( c->linger_timer );
    #####: 2050:	c->linger_timer = (Timer*) 0;
    #####: 2051:	c->hc->should_linger = 0;
        -: 2052:	}
    #####: 2053:    if ( c->hc->should_linger )
        -: 2054:	{
    #####: 2055:	if ( c->conn_state != CNST_PAUSING )
    #####: 2056:	    fdwatch_del_fd( c->hc->conn_fd );
    #####: 2057:	c->conn_state = CNST_LINGERING;
    #####: 2058:	shutdown( c->hc->conn_fd, SHUT_WR );
    #####: 2059:	fdwatch_add_fd( c->hc->conn_fd, c, FDW_READ );
    #####: 2060:	client_data.p = c;
    #####: 2061:	if ( c->linger_timer != (Timer*) 0 )
    #####: 2062:	    syslog( LOG_ERR, "replacing non-null linger_timer!" );
    #####: 2063:	c->linger_timer = tmr_create(
        -: 2064:	    tvP, linger_clear_connection, client_data, LINGER_TIME, 0 );
    #####: 2065:	if ( c->linger_timer == (Timer*) 0 )
        -: 2066:	    {
    #####: 2067:	    syslog( LOG_CRIT, "tmr_create(linger_clear_connection) failed" );
    #####: 2068:	    exit( 1 );
        -: 2069:	    }
        -: 2070:	}
        -: 2071:    else
    #####: 2072:	really_clear_connection( c, tvP );
    #####: 2073:    }
        -: 2074:
        -: 2075:
        -: 2076:static void
    #####: 2077:really_clear_connection( connecttab* c, struct timeval* tvP )
        -: 2078:    {
    #####: 2079:    stats_bytes += c->hc->bytes_sent;
    #####: 2080:    if ( c->conn_state != CNST_PAUSING )
    #####: 2081:	fdwatch_del_fd( c->hc->conn_fd );
    #####: 2082:    httpd_close_conn( c->hc, tvP );
    #####: 2083:    clear_throttles( c, tvP );
    #####: 2084:    if ( c->linger_timer != (Timer*) 0 )
        -: 2085:	{
    #####: 2086:	tmr_cancel( c->linger_timer );
    #####: 2087:	c->linger_timer = 0;
        -: 2088:	}
    #####: 2089:    c->conn_state = CNST_FREE;
    #####: 2090:    c->next_free_connect = first_free_connect;
    #####: 2091:    first_free_connect = c - connects;	/* division by sizeof is implied */
    #####: 2092:    --num_connects;
    #####: 2093:    }
        -: 2094:
        -: 2095:
        -: 2096:static void
    #####: 2097:idle( ClientData client_data, struct timeval* nowP )
        -: 2098:    {
        -: 2099:    int cnum;
        -: 2100:    connecttab* c;
        -: 2101:
    #####: 2102:    for ( cnum = 0; cnum < max_connects; ++cnum )
        -: 2103:	{
    #####: 2104:	c = &connects[cnum];
    #####: 2105:	switch ( c->conn_state )
        -: 2106:	    {
        -: 2107:	    case CNST_READING:
    #####: 2108:	    if ( nowP->tv_sec - c->active_at >= IDLE_READ_TIMELIMIT )
        -: 2109:		{
    #####: 2110:		syslog( LOG_INFO,
        -: 2111:		    "%.80s connection timed out reading",
    #####: 2112:		    httpd_ntoa( &c->hc->client_addr ) );
    #####: 2113:		httpd_send_err(
        -: 2114:		    c->hc, 408, httpd_err408title, "", httpd_err408form, "" );
    #####: 2115:		finish_connection( c, nowP );
        -: 2116:		}
    #####: 2117:	    break;
        -: 2118:	    case CNST_SENDING:
        -: 2119:	    case CNST_PAUSING:
    #####: 2120:	    if ( nowP->tv_sec - c->active_at >= IDLE_SEND_TIMELIMIT )
        -: 2121:		{
    #####: 2122:		syslog( LOG_INFO,
        -: 2123:		    "%.80s connection timed out sending",
    #####: 2124:		    httpd_ntoa( &c->hc->client_addr ) );
    #####: 2125:		clear_connection( c, nowP );
        -: 2126:		}
    #####: 2127:	    break;
        -: 2128:	    }
        -: 2129:	}
    #####: 2130:    }
        -: 2131:
        -: 2132:
        -: 2133:static void
    #####: 2134:wakeup_connection( ClientData client_data, struct timeval* nowP )
        -: 2135:    {
        -: 2136:    connecttab* c;
        -: 2137:
    #####: 2138:    c = (connecttab*) client_data.p;
    #####: 2139:    c->wakeup_timer = (Timer*) 0;
    #####: 2140:    if ( c->conn_state == CNST_PAUSING )
        -: 2141:	{
    #####: 2142:	c->conn_state = CNST_SENDING;
    #####: 2143:	fdwatch_add_fd( c->hc->conn_fd, c, FDW_WRITE );
        -: 2144:	}
    #####: 2145:    }
        -: 2146:
        -: 2147:static void
    #####: 2148:linger_clear_connection( ClientData client_data, struct timeval* nowP )
        -: 2149:    {
        -: 2150:    connecttab* c;
        -: 2151:
    #####: 2152:    c = (connecttab*) client_data.p;
    #####: 2153:    c->linger_timer = (Timer*) 0;
    #####: 2154:    really_clear_connection( c, nowP );
    #####: 2155:    }
        -: 2156:
        -: 2157:
        -: 2158:static void
    #####: 2159:occasional( ClientData client_data, struct timeval* nowP )
        -: 2160:    {
    #####: 2161:    mmc_cleanup( nowP );
    #####: 2162:    tmr_cleanup();
    #####: 2163:    watchdog_flag = 1;		/* let the watchdog know that we are alive */
    #####: 2164:    }
        -: 2165:
        -: 2166:
        -: 2167:#ifdef STATS_TIME
        -: 2168:static void
    #####: 2169:show_stats( ClientData client_data, struct timeval* nowP )
        -: 2170:    {
    #####: 2171:    logstats( nowP );
    #####: 2172:    }
        -: 2173:#endif /* STATS_TIME */
        -: 2174:
        -: 2175:
        -: 2176:/* Generate debugging statistics syslog messages for all packages. */
        -: 2177:static void
    #####: 2178:logstats( struct timeval* nowP )
        -: 2179:    {
        -: 2180:    struct timeval tv;
        -: 2181:    time_t now;
        -: 2182:    long up_secs, stats_secs;
        -: 2183:
    #####: 2184:    if ( nowP == (struct timeval*) 0 )
        -: 2185:	{
    #####: 2186:	(void) gettimeofday( &tv, (struct timezone*) 0 );
    #####: 2187:	nowP = &tv;
        -: 2188:	}
    #####: 2189:    now = nowP->tv_sec;
    #####: 2190:    up_secs = now - start_time;
    #####: 2191:    stats_secs = now - stats_time;
    #####: 2192:    if ( stats_secs == 0 )
    #####: 2193:	stats_secs = 1;	/* fudge */
    #####: 2194:    stats_time = now;
    #####: 2195:    syslog( LOG_NOTICE,
        -: 2196:	"up %ld seconds, stats for %ld seconds:", up_secs, stats_secs );
        -: 2197:
    #####: 2198:    thttpd_logstats( stats_secs );
    #####: 2199:    httpd_logstats( stats_secs );
    #####: 2200:    mmc_logstats( stats_secs );
    #####: 2201:    fdwatch_logstats( stats_secs );
    #####: 2202:    tmr_logstats( stats_secs );
    #####: 2203:    }
        -: 2204:
        -: 2205:
        -: 2206:/* Generate debugging statistics syslog message. */
        -: 2207:static void
    #####: 2208:thttpd_logstats( long secs )
        -: 2209:    {
    #####: 2210:    if ( secs > 0 )
    #####: 2211:	syslog( LOG_NOTICE,
        -: 2212:	    "  thttpd - %ld connections (%g/sec), %d max simultaneous, %lld bytes (%g/sec), %d httpd_conns allocated",
    #####: 2213:	    stats_connections, (float) stats_connections / secs,
        -: 2214:	    stats_simultaneous, (long long) stats_bytes,
    #####: 2215:	    (float) stats_bytes / secs, httpd_conn_count );
    #####: 2216:    stats_connections = 0;
    #####: 2217:    stats_bytes = 0;
    #####: 2218:    stats_simultaneous = 0;
    #####: 2219:    }
