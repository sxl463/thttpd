        -:    0:Source:thttpd.c
        -:    0:Programs:7
        -:    1:/* thttpd.c - tiny/turbo/throttling HTTP server
        -:    2:**
        -:    3:** Copyright © 1995,1998,1999,2000,2001,2015 by
        -:    4:** Jef Poskanzer <jef@mail.acme.com>. All rights reserved.
        -:    5:**
        -:    6:** Redistribution and use in source and binary forms, with or without
        -:    7:** modification, are permitted provided that the following conditions
        -:    8:** are met:
        -:    9:** 1. Redistributions of source code must retain the above copyright
        -:   10:**    notice, this list of conditions and the following disclaimer.
        -:   11:** 2. Redistributions in binary form must reproduce the above copyright
        -:   12:**    notice, this list of conditions and the following disclaimer in the
        -:   13:**    documentation and/or other materials provided with the distribution.
        -:   14:**
        -:   15:** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
        -:   16:** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   17:** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        -:   18:** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        -:   19:** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        -:   20:** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        -:   21:** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:   22:** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        -:   23:** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        -:   24:** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        -:   25:** SUCH DAMAGE.
        -:   26:*/
        -:   27:
        -:   28:
        -:   29:#include "config.h"
        -:   30:#include "version.h"
        -:   31:
        -:   32:#include <sys/param.h>
        -:   33:#include <sys/types.h>
        -:   34:#include <sys/time.h>
        -:   35:#include <sys/stat.h>
        -:   36:#include <sys/wait.h>
        -:   37:#include <sys/uio.h>
        -:   38:
        -:   39:#include <errno.h>
        -:   40:#ifdef HAVE_FCNTL_H
        -:   41:#include <fcntl.h>
        -:   42:#endif
        -:   43:#include <pwd.h>
        -:   44:#ifdef HAVE_GRP_H
        -:   45:#include <grp.h>
        -:   46:#endif
        -:   47:#include <signal.h>
        -:   48:#include <stdio.h>
        -:   49:#include <stdlib.h>
        -:   50:#include <string.h>
        -:   51:#include <syslog.h>
        -:   52:#ifdef TIME_WITH_SYS_TIME
        -:   53:#include <time.h>
        -:   54:#endif
        -:   55:#include <unistd.h>
        -:   56:
        -:   57:#include "fdwatch.h"
        -:   58:#include "libhttpd.h"
        -:   59:#include "mmc.h"
        -:   60:#include "timers.h"
        -:   61:#include "match.h"
        -:   62:
        -:   63:#ifndef SHUT_WR
        -:   64:#define SHUT_WR 1
        -:   65:#endif
        -:   66:
        -:   67:#ifndef HAVE_INT64T
        -:   68:typedef long long int64_t;
        -:   69:#endif
        -:   70:
        -:   71://added by shen
        -:   72:static count = 0;
        -:   73:/*
        -:   74:static unsigned long long i = 0;
        -:   75:void __gcov_flush(void); // check in gcc sources gcc/gcov-io.h for the prototype 
        -:   76:void my_handler(int signum)
        -:   77:{
        -:   78:  printf("received signal\n");
        -:   79:  printf("%llu\n", i);
        -:   80:  __gcov_flush(); // dump coverage data on receiving SIGUSR1 
        -:   81:  printf("flushed\n");
        -:   82:  exit(0);
        -:   83:}*/
        -:   84:
        -:   85:static char* argv0;
        -:   86:static int debug;
        -:   87:static unsigned short port;
        -:   88:static char* dir;
        -:   89:static char* data_dir;
        -:   90:static int do_chroot, no_log, no_symlink_check, do_vhost, do_global_passwd;
        -:   91:static char* cgi_pattern;
        -:   92:static int cgi_limit;
        -:   93:static char* url_pattern;
        -:   94:static int no_empty_referrers;
        -:   95:static char* local_pattern;
        -:   96:static char* logfile;
        -:   97:static char* throttlefile;
        -:   98:static char* hostname;
        -:   99:static char* pidfile;
        -:  100:static char* user;
        -:  101:static char* charset;
        -:  102:static char* p3p;
        -:  103:static int max_age;
        -:  104:
        -:  105:
        -:  106:typedef struct {
        -:  107:    char* pattern;
        -:  108:    long max_limit, min_limit;
        -:  109:    long rate;
        -:  110:    off_t bytes_since_avg;
        -:  111:    int num_sending;
        -:  112:    } throttletab;
        -:  113:static throttletab* throttles;
        -:  114:static int numthrottles, maxthrottles;
        -:  115:
        -:  116:#define THROTTLE_NOLIMIT -1
        -:  117:
        -:  118:
        -:  119:typedef struct {
        -:  120:    int conn_state;
        -:  121:    int next_free_connect;
        -:  122:    httpd_conn* hc;
        -:  123:    int tnums[MAXTHROTTLENUMS];         /* throttle indexes */
        -:  124:    int numtnums;
        -:  125:    long max_limit, min_limit;
        -:  126:    time_t started_at, active_at;
        -:  127:    Timer* wakeup_timer;
        -:  128:    Timer* linger_timer;
        -:  129:    long wouldblock_delay;
        -:  130:    off_t bytes;
        -:  131:    off_t end_byte_index;
        -:  132:    off_t next_byte_index;
        -:  133:    } connecttab;
        -:  134:static connecttab* connects;
        -:  135:static int num_connects, max_connects, first_free_connect;
        -:  136:static int httpd_conn_count;
        -:  137:
        -:  138:/* The connection states. */
        -:  139:#define CNST_FREE 0
        -:  140:#define CNST_READING 1
        -:  141:#define CNST_SENDING 2
        -:  142:#define CNST_PAUSING 3
        -:  143:#define CNST_LINGERING 4
        -:  144:
        -:  145:
        -:  146:static httpd_server* hs = (httpd_server*) 0;
        -:  147:int terminate = 0;
        -:  148:time_t start_time, stats_time;
        -:  149:long stats_connections;
        -:  150:off_t stats_bytes;
        -:  151:int stats_simultaneous;
        -:  152:
        -:  153:static volatile int got_hup, got_usr1, watchdog_flag;
        -:  154:
        -:  155:
        -:  156:/* Forwards. */
        -:  157:static void parse_args( int argc, char** argv );
        -:  158:static void usage( void );
        -:  159:static void read_config( char* filename );
        -:  160:static void value_required( char* name, char* value );
        -:  161:static void no_value_required( char* name, char* value );
        -:  162:static char* e_strdup( char* oldstr );
        -:  163:static void lookup_hostname( httpd_sockaddr* sa4P, size_t sa4_len, int* gotv4P, httpd_sockaddr* sa6P, size_t sa6_len, int* gotv6P );
        -:  164:static void read_throttlefile( char* tf );
        -:  165:static void shut_down( void );
        -:  166:static int handle_newconnect( struct timeval* tvP, int listen_fd );
        -:  167:static void handle_read( connecttab* c, struct timeval* tvP );
        -:  168:static void handle_send( connecttab* c, struct timeval* tvP );
        -:  169:static void handle_linger( connecttab* c, struct timeval* tvP );
        -:  170:static int check_throttles( connecttab* c );
        -:  171:static void clear_throttles( connecttab* c, struct timeval* tvP );
        -:  172:static void update_throttles( ClientData client_data, struct timeval* nowP );
        -:  173:static void finish_connection( connecttab* c, struct timeval* tvP );
        -:  174:static void clear_connection( connecttab* c, struct timeval* tvP );
        -:  175:static void really_clear_connection( connecttab* c, struct timeval* tvP );
        -:  176:static void idle( ClientData client_data, struct timeval* nowP );
        -:  177:static void wakeup_connection( ClientData client_data, struct timeval* nowP );
        -:  178:static void linger_clear_connection( ClientData client_data, struct timeval* nowP );
        -:  179:static void occasional( ClientData client_data, struct timeval* nowP );
        -:  180:#ifdef STATS_TIME
        -:  181:static void show_stats( ClientData client_data, struct timeval* nowP );
        -:  182:#endif /* STATS_TIME */
        -:  183:static void logstats( struct timeval* nowP );
        -:  184:static void thttpd_logstats( long secs );
        -:  185:
        -:  186:
        -:  187:/* SIGTERM and SIGINT say to exit immediately. */
        -:  188:static void
    #####:  189:handle_term( int sig )
        -:  190:    {
        -:  191:    /* Don't need to set up the handler again, since it's a one-shot. */
        -:  192:
    #####:  193:    shut_down();
    #####:  194:    syslog( LOG_NOTICE, "exiting due to signal %d", sig );
    #####:  195:    closelog();
    #####:  196:    exit( 1 );
        -:  197:    }
        -:  198:
        -:  199:
        -:  200:/* SIGCHLD - a chile process exitted, so we need to reap the zombie */
        -:  201:static void
    #####:  202:handle_chld( int sig )
        -:  203:    {
    #####:  204:    const int oerrno = errno;
        -:  205:    pid_t pid;
        -:  206:    int status;
        -:  207:
        -:  208:#ifndef HAVE_SIGSET
        -:  209:    /* Set up handler again. */
        -:  210:    (void) signal( SIGCHLD, handle_chld );
        -:  211:#endif /* ! HAVE_SIGSET */
        -:  212:
        -:  213:    /* Reap defunct children until there aren't any more. */
        -:  214:    for (;;)
        -:  215:	{
        -:  216:#ifdef HAVE_WAITPID
    #####:  217:	pid = waitpid( (pid_t) -1, &status, WNOHANG );
        -:  218:#else /* HAVE_WAITPID */
        -:  219:	pid = wait3( &status, WNOHANG, (struct rusage*) 0 );
        -:  220:#endif /* HAVE_WAITPID */
    #####:  221:	if ( (int) pid == 0 )		/* none left */
    #####:  222:	    break;
    #####:  223:	if ( (int) pid < 0 )
        -:  224:	    {
    #####:  225:	    if ( errno == EINTR || errno == EAGAIN )
    #####:  226:		continue;
        -:  227:	    /* ECHILD shouldn't happen with the WNOHANG option,
        -:  228:	    ** but with some kernels it does anyway.  Ignore it.
        -:  229:	    */
    #####:  230:	    if ( errno != ECHILD )
    #####:  231:		syslog( LOG_ERR, "child wait - %m" );
    #####:  232:	    break;
        -:  233:	    }
        -:  234:	/* Decrement the CGI count.  Note that this is not accurate, since
        -:  235:	** each CGI can involve two or even three child processes.
        -:  236:	** Decrementing for each child means that when there is heavy CGI
        -:  237:	** activity, the count will be lower than it should be, and therefore
        -:  238:	** more CGIs will be allowed than should be.
        -:  239:	*/
    #####:  240:	if ( hs != (httpd_server*) 0 )
        -:  241:	    {
    #####:  242:	    --hs->cgi_count;
    #####:  243:	    if ( hs->cgi_count < 0 )
    #####:  244:		hs->cgi_count = 0;
        -:  245:	    }
    #####:  246:	}
        -:  247:
        -:  248:    /* Restore previous errno. */
    #####:  249:    errno = oerrno;
    #####:  250:    }
        -:  251:
        -:  252:
        -:  253:/* SIGHUP says to re-open the log file. */
        -:  254:static void
    #####:  255:handle_hup( int sig )
        -:  256:    {
    #####:  257:    const int oerrno = errno;
        -:  258:
        -:  259:#ifndef HAVE_SIGSET
        -:  260:    /* Set up handler again. */
        -:  261:    (void) signal( SIGHUP, handle_hup );
        -:  262:#endif /* ! HAVE_SIGSET */
        -:  263:
        -:  264:    /* Just set a flag that we got the signal. */
    #####:  265:    got_hup = 1;
        -:  266:
        -:  267:    /* Restore previous errno. */
    #####:  268:    errno = oerrno;
    #####:  269:    }
        -:  270:
        -:  271:
        -:  272:/* SIGUSR1 says to exit as soon as all current connections are done. */
        -:  273:static void
    #####:  274:handle_usr1( int sig )
        -:  275:    {
        -:  276:    /* Don't need to set up the handler again, since it's a one-shot. */
        -:  277:
    #####:  278:    if ( num_connects == 0 )
        -:  279:	{
        -:  280:	/* If there are no active connections we want to exit immediately
        -:  281:	** here.  Not only is it faster, but without any connections the
        -:  282:	** main loop won't wake up until the next new connection.
        -:  283:	*/
    #####:  284:	shut_down();
    #####:  285:	syslog( LOG_NOTICE, "exiting" );
    #####:  286:	closelog();
    #####:  287:	exit( 0 );
        -:  288:	}
        -:  289:
        -:  290:    /* Otherwise, just set a flag that we got the signal. */
    #####:  291:    got_usr1 = 1;
        -:  292:
        -:  293:    /* Don't need to restore old errno, since we didn't do any syscalls. */
    #####:  294:    }
        -:  295:
        -:  296:
        -:  297:/* SIGUSR2 says to generate the stats syslogs immediately. */
        -:  298:static void
    #####:  299:handle_usr2( int sig )
        -:  300:    {
    #####:  301:    const int oerrno = errno;
        -:  302:
        -:  303:#ifndef HAVE_SIGSET
        -:  304:    /* Set up handler again. */
        -:  305:    (void) signal( SIGUSR2, handle_usr2 );
        -:  306:#endif /* ! HAVE_SIGSET */
        -:  307:
    #####:  308:    logstats( (struct timeval*) 0 );
        -:  309:
        -:  310:    /* Restore previous errno. */
    #####:  311:    errno = oerrno;
    #####:  312:    }
        -:  313:
        -:  314:
        -:  315:/* SIGALRM is used as a watchdog. */
        -:  316:static void
    #####:  317:handle_alrm( int sig )
        -:  318:    {
    #####:  319:    const int oerrno = errno;
        -:  320:
        -:  321:    /* If nothing has been happening */
    #####:  322:    if ( ! watchdog_flag )
        -:  323:	{
        -:  324:	/* Try changing dirs to someplace we can write. */
    #####:  325:	(void) chdir( "/tmp" );
        -:  326:	/* Dump core. */
    #####:  327:	abort();
        -:  328:	}
    #####:  329:    watchdog_flag = 0;
        -:  330:
        -:  331:#ifndef HAVE_SIGSET
        -:  332:    /* Set up handler again. */
        -:  333:    (void) signal( SIGALRM, handle_alrm );
        -:  334:#endif /* ! HAVE_SIGSET */
        -:  335:    /* Set up alarm again. */
    #####:  336:    (void) alarm( OCCASIONAL_TIME * 3 );
        -:  337:
        -:  338:    /* Restore previous errno. */
    #####:  339:    errno = oerrno;
    #####:  340:    }
        -:  341:
        -:  342:
        -:  343:static void
    #####:  344:re_open_logfile( void )
        -:  345:    {
        -:  346:    FILE* logfp;
        -:  347:
    #####:  348:    if ( no_log || hs == (httpd_server*) 0 )
    #####:  349:	return;
        -:  350:
        -:  351:    /* Re-open the log file. */
    #####:  352:    if ( logfile != (char*) 0 && strcmp( logfile, "-" ) != 0 )
        -:  353:	{
    #####:  354:	syslog( LOG_NOTICE, "re-opening logfile" );
    #####:  355:	logfp = fopen( logfile, "a" );
    #####:  356:	if ( logfp == (FILE*) 0 )
        -:  357:	    {
    #####:  358:	    syslog( LOG_CRIT, "re-opening %.80s - %m", logfile );
    #####:  359:	    return;
        -:  360:	    }
    #####:  361:	(void) fcntl( fileno( logfp ), F_SETFD, 1 );
    #####:  362:	httpd_set_logfp( hs, logfp );
        -:  363:	}
        -:  364:    }
        -:  365:
        -:  366:
        -:  367:int
        1:  368:main( int argc, char** argv )
        -:  369:    {
        -:  370:    char* cp;
        -:  371:    struct passwd* pwd;
        1:  372:    uid_t uid = 32767;
        1:  373:    gid_t gid = 32767;
        -:  374:    char cwd[MAXPATHLEN+1];
        -:  375:    FILE* logfp;
        -:  376:    int num_ready;
        -:  377:    int cnum;
        -:  378:    connecttab* c;
        -:  379:    httpd_conn* hc;
        -:  380:    httpd_sockaddr sa4;
        -:  381:    httpd_sockaddr sa6;
        -:  382:    int gotv4, gotv6;
        -:  383:    struct timeval tv;
        -:  384:
        1:  385:    argv0 = argv[0];
        -:  386:
        1:  387:    cp = strrchr( argv0, '/' );
        1:  388:    if ( cp != (char*) 0 )
        1:  389:	++cp;
        -:  390:    else
    #####:  391:	cp = argv0;
        1:  392:    openlog( cp, LOG_NDELAY|LOG_PID, LOG_FACILITY );
        -:  393:
        -:  394:    /* Handle command-line arguments. */
        1:  395:    parse_args( argc, argv );
        -:  396:
        -:  397:    /* Read zone info now, in case we chroot(). */
    #####:  398:    tzset();
        -:  399:
        -:  400:    /* Look up hostname now, in case we chroot(). */
    #####:  401:    lookup_hostname( &sa4, sizeof(sa4), &gotv4, &sa6, sizeof(sa6), &gotv6 );
    #####:  402:    if ( ! ( gotv4 || gotv6 ) )
        -:  403:	{
    #####:  404:	syslog( LOG_ERR, "can't find any valid address" );
    #####:  405:	(void) fprintf( stderr, "%s: can't find any valid address\n", argv0 );
    #####:  406:	exit( 1 );
        -:  407:	}
        -:  408:
        -:  409:    /* Throttle file. */
    #####:  410:    numthrottles = 0;
    #####:  411:    maxthrottles = 0;
    #####:  412:    throttles = (throttletab*) 0;
    #####:  413:    if ( throttlefile != (char*) 0 )
    #####:  414:	read_throttlefile( throttlefile );
        -:  415:
        -:  416:    /* If we're root and we're going to become another user, get the uid/gid
        -:  417:    ** now.
        -:  418:    */
    #####:  419:    if ( getuid() == 0 )
        -:  420:	{
    #####:  421:	pwd = getpwnam( user );
    #####:  422:	if ( pwd == (struct passwd*) 0 )
        -:  423:	    {
    #####:  424:	    syslog( LOG_CRIT, "unknown user - '%.80s'", user );
    #####:  425:	    (void) fprintf( stderr, "%s: unknown user - '%s'\n", argv0, user );
    #####:  426:	    exit( 1 );
        -:  427:	    }
    #####:  428:	uid = pwd->pw_uid;
    #####:  429:	gid = pwd->pw_gid;
        -:  430:	}
        -:  431:
        -:  432:    /* Log file. */
    #####:  433:    if ( logfile != (char*) 0 )
        -:  434:	{
    #####:  435:	if ( strcmp( logfile, "/dev/null" ) == 0 )
        -:  436:	    {
    #####:  437:	    no_log = 1;
    #####:  438:	    logfp = (FILE*) 0;
        -:  439:	    }
    #####:  440:	else if ( strcmp( logfile, "-" ) == 0 )
    #####:  441:	    logfp = stdout;
        -:  442:	else
        -:  443:	    {
    #####:  444:	    logfp = fopen( logfile, "a" );
    #####:  445:	    if ( logfp == (FILE*) 0 )
        -:  446:		{
    #####:  447:		syslog( LOG_CRIT, "%.80s - %m", logfile );
    #####:  448:		perror( logfile );
    #####:  449:		exit( 1 );
        -:  450:		}
    #####:  451:	    if ( logfile[0] != '/' )
        -:  452:		{
    #####:  453:		syslog( LOG_WARNING, "logfile is not an absolute path, you may not be able to re-open it" );
    #####:  454:		(void) fprintf( stderr, "%s: logfile is not an absolute path, you may not be able to re-open it\n", argv0 );
        -:  455:		}
    #####:  456:	    (void) fcntl( fileno( logfp ), F_SETFD, 1 );
    #####:  457:	    if ( getuid() == 0 )
        -:  458:		{
        -:  459:		/* If we are root then we chown the log file to the user we'll
        -:  460:		** be switching to.
        -:  461:		*/
    #####:  462:		if ( fchown( fileno( logfp ), uid, gid ) < 0 )
        -:  463:		    {
    #####:  464:		    syslog( LOG_WARNING, "fchown logfile - %m" );
    #####:  465:		    perror( "fchown logfile" );
        -:  466:		    }
        -:  467:		}
        -:  468:	    }
        -:  469:	}
        -:  470:    else
    #####:  471:	logfp = (FILE*) 0;
        -:  472:
        -:  473:    /* Switch directories if requested. */
    #####:  474:    if ( dir != (char*) 0 )
        -:  475:	{
    #####:  476:	if ( chdir( dir ) < 0 )
        -:  477:	    {
    #####:  478:	    syslog( LOG_CRIT, "chdir - %m" );
    #####:  479:	    perror( "chdir" );
    #####:  480:	    exit( 1 );
        -:  481:	    }
        -:  482:	}
        -:  483:#ifdef USE_USER_DIR
        -:  484:    else if ( getuid() == 0 )
        -:  485:	{
        -:  486:	/* No explicit directory was specified, we're root, and the
        -:  487:	** USE_USER_DIR option is set - switch to the specified user's
        -:  488:	** home dir.
        -:  489:	*/
        -:  490:	if ( chdir( pwd->pw_dir ) < 0 )
        -:  491:	    {
        -:  492:	    syslog( LOG_CRIT, "chdir - %m" );
        -:  493:	    perror( "chdir" );
        -:  494:	    exit( 1 );
        -:  495:	    }
        -:  496:	}
        -:  497:#endif /* USE_USER_DIR */
        -:  498:
        -:  499:    /* Get current directory. */
    #####:  500:    (void) getcwd( cwd, sizeof(cwd) - 1 );
    #####:  501:    if ( cwd[strlen( cwd ) - 1] != '/' )
    #####:  502:	(void) strcat( cwd, "/" );
        -:  503:
    #####:  504:    if ( ! debug )
        -:  505:	{
        -:  506:	/* We're not going to use stdin stdout or stderr from here on, so close
        -:  507:	** them to save file descriptors.
        -:  508:	*/
    #####:  509:	(void) fclose( stdin );
    #####:  510:	if ( logfp != stdout )
    #####:  511:	    (void) fclose( stdout );
    #####:  512:	(void) fclose( stderr );
        -:  513:
        -:  514:	/* Daemonize - make ourselves a subprocess. */
        -:  515:#ifdef HAVE_DAEMON
    #####:  516:	if ( daemon( 1, 1 ) < 0 )
        -:  517:	    {
    #####:  518:	    syslog( LOG_CRIT, "daemon - %m" );
    #####:  519:	    exit( 1 );
        -:  520:	    }
        -:  521:#else /* HAVE_DAEMON */
        -:  522:	switch ( fork() )
        -:  523:	    {
        -:  524:	    case 0:
        -:  525:	    break;
        -:  526:	    case -1:
        -:  527:	    syslog( LOG_CRIT, "fork - %m" );
        -:  528:	    exit( 1 );
        -:  529:	    default:
        -:  530:	    exit( 0 );
        -:  531:	    }
        -:  532:#ifdef HAVE_SETSID
        -:  533:        (void) setsid();
        -:  534:#endif /* HAVE_SETSID */
        -:  535:#endif /* HAVE_DAEMON */
        -:  536:	}
        -:  537:    else
        -:  538:	{
        -:  539:	/* Even if we don't daemonize, we still want to disown our parent
        -:  540:	** process.
        -:  541:	*/
        -:  542:#ifdef HAVE_SETSID
    #####:  543:        (void) setsid();
        -:  544:#endif /* HAVE_SETSID */
        -:  545:	}
        -:  546:
    #####:  547:    if ( pidfile != (char*) 0 )
        -:  548:	{
        -:  549:	/* Write the PID file. */
    #####:  550:	FILE* pidfp = fopen( pidfile, "w" );
    #####:  551:	if ( pidfp == (FILE*) 0 )
        -:  552:	    {
    #####:  553:	    syslog( LOG_CRIT, "%.80s - %m", pidfile );
    #####:  554:	    exit( 1 );
        -:  555:	    }
    #####:  556:	(void) fprintf( pidfp, "%d\n", (int) getpid() );
    #####:  557:	(void) fclose( pidfp );
        -:  558:	}
        -:  559:
        -:  560:    /* Initialize the fdwatch package.  Have to do this before chroot,
        -:  561:    ** if /dev/poll is used.
        -:  562:    */
    #####:  563:    max_connects = fdwatch_get_nfiles();
    #####:  564:    if ( max_connects < 0 )
        -:  565:	{
    #####:  566:	syslog( LOG_CRIT, "fdwatch initialization failure" );
    #####:  567:	exit( 1 );
        -:  568:	}
    #####:  569:    max_connects -= SPARE_FDS;
        -:  570:
        -:  571:    /* Chroot if requested. */
    #####:  572:    if ( do_chroot )
        -:  573:	{
    #####:  574:	if ( chroot( cwd ) < 0 )
        -:  575:	    {
    #####:  576:	    syslog( LOG_CRIT, "chroot - %m" );
    #####:  577:	    perror( "chroot" );
    #####:  578:	    exit( 1 );
        -:  579:	    }
        -:  580:	/* If we're logging and the logfile's pathname begins with the
        -:  581:	** chroot tree's pathname, then elide the chroot pathname so
        -:  582:	** that the logfile pathname still works from inside the chroot
        -:  583:	** tree.
        -:  584:	*/
    #####:  585:	if ( logfile != (char*) 0 && strcmp( logfile, "-" ) != 0 )
        -:  586:	    {
    #####:  587:	    if ( strncmp( logfile, cwd, strlen( cwd ) ) == 0 )
        -:  588:		{
    #####:  589:		(void) ol_strcpy( logfile, &logfile[strlen( cwd ) - 1] );
        -:  590:		/* (We already guaranteed that cwd ends with a slash, so leaving
        -:  591:		** that slash in logfile makes it an absolute pathname within
        -:  592:		** the chroot tree.)
        -:  593:		*/
        -:  594:		}
        -:  595:	    else
        -:  596:		{
    #####:  597:		syslog( LOG_WARNING, "logfile is not within the chroot tree, you will not be able to re-open it" );
    #####:  598:		(void) fprintf( stderr, "%s: logfile is not within the chroot tree, you will not be able to re-open it\n", argv0 );
        -:  599:		}
        -:  600:	    }
    #####:  601:	(void) strcpy( cwd, "/" );
        -:  602:	/* Always chdir to / after a chroot. */
    #####:  603:	if ( chdir( cwd ) < 0 )
        -:  604:	    {
    #####:  605:	    syslog( LOG_CRIT, "chroot chdir - %m" );
    #####:  606:	    perror( "chroot chdir" );
    #####:  607:	    exit( 1 );
        -:  608:	    }
        -:  609:	}
        -:  610:
        -:  611:    /* Switch directories again if requested. */
    #####:  612:    if ( data_dir != (char*) 0 )
        -:  613:	{
    #####:  614:	if ( chdir( data_dir ) < 0 )
        -:  615:	    {
    #####:  616:	    syslog( LOG_CRIT, "data_dir chdir - %m" );
    #####:  617:	    perror( "data_dir chdir" );
    #####:  618:	    exit( 1 );
        -:  619:	    }
        -:  620:	}
        -:  621:
        -:  622:    /* Set up to catch signals. */
        -:  623:#ifdef HAVE_SIGSET
    #####:  624:    (void) sigset( SIGTERM, handle_term );
    #####:  625:    (void) sigset( SIGINT, handle_term );
    #####:  626:    (void) sigset( SIGCHLD, handle_chld );
    #####:  627:    (void) sigset( SIGPIPE, SIG_IGN );          /* get EPIPE instead */
    #####:  628:    (void) sigset( SIGHUP, handle_hup );
    #####:  629:    (void) sigset( SIGUSR1, handle_usr1 );
    #####:  630:    (void) sigset( SIGUSR2, handle_usr2 );
    #####:  631:    (void) sigset( SIGALRM, handle_alrm );
        -:  632:#else /* HAVE_SIGSET */
        -:  633:    (void) signal( SIGTERM, handle_term );
        -:  634:    (void) signal( SIGINT, handle_term );
        -:  635:    (void) signal( SIGCHLD, handle_chld );
        -:  636:    (void) signal( SIGPIPE, SIG_IGN );          /* get EPIPE instead */
        -:  637:    (void) signal( SIGHUP, handle_hup );
        -:  638:    (void) signal( SIGUSR1, handle_usr1 );
        -:  639:    (void) signal( SIGUSR2, handle_usr2 );
        -:  640:    (void) signal( SIGALRM, handle_alrm );
        -:  641:#endif /* HAVE_SIGSET */
    #####:  642:    got_hup = 0;
    #####:  643:    got_usr1 = 0;
    #####:  644:    watchdog_flag = 0;
    #####:  645:    (void) alarm( OCCASIONAL_TIME * 3 );
        -:  646:
        -:  647:    /* Initialize the timer package. */
    #####:  648:    tmr_init();
        -:  649:
        -:  650:    /* Initialize the HTTP layer.  Got to do this before giving up root,
        -:  651:    ** so that we can bind to a privileged port.
        -:  652:    */
    #####:  653:    hs = httpd_initialize(
        -:  654:	hostname,
    #####:  655:	gotv4 ? &sa4 : (httpd_sockaddr*) 0, gotv6 ? &sa6 : (httpd_sockaddr*) 0,
        -:  656:	port, cgi_pattern, cgi_limit, charset, p3p, max_age, cwd, no_log, logfp,
        -:  657:	no_symlink_check, do_vhost, do_global_passwd, url_pattern,
        -:  658:	local_pattern, no_empty_referrers );
    #####:  659:    if ( hs == (httpd_server*) 0 )
    #####:  660:	exit( 1 );
        -:  661:
        -:  662:    /* Set up the occasional timer. */
    #####:  663:    if ( tmr_create( (struct timeval*) 0, occasional, JunkClientData, OCCASIONAL_TIME * 1000L, 1 ) == (Timer*) 0 )
        -:  664:	{
    #####:  665:	syslog( LOG_CRIT, "tmr_create(occasional) failed" );
    #####:  666:	exit( 1 );
        -:  667:	}
        -:  668:    /* Set up the idle timer. */
    #####:  669:    if ( tmr_create( (struct timeval*) 0, idle, JunkClientData, 5 * 1000L, 1 ) == (Timer*) 0 )
        -:  670:	{
    #####:  671:	syslog( LOG_CRIT, "tmr_create(idle) failed" );
    #####:  672:	exit( 1 );
        -:  673:	}
    #####:  674:    if ( numthrottles > 0 )
        -:  675:	{
        -:  676:	/* Set up the throttles timer. */
    #####:  677:	if ( tmr_create( (struct timeval*) 0, update_throttles, JunkClientData, THROTTLE_TIME * 1000L, 1 ) == (Timer*) 0 )
        -:  678:	    {
    #####:  679:	    syslog( LOG_CRIT, "tmr_create(update_throttles) failed" );
    #####:  680:	    exit( 1 );
        -:  681:	    }
        -:  682:	}
        -:  683:#ifdef STATS_TIME
        -:  684:    /* Set up the stats timer. */
    #####:  685:    if ( tmr_create( (struct timeval*) 0, show_stats, JunkClientData, STATS_TIME * 1000L, 1 ) == (Timer*) 0 )
        -:  686:	{
    #####:  687:	syslog( LOG_CRIT, "tmr_create(show_stats) failed" );
    #####:  688:	exit( 1 );
        -:  689:	}
        -:  690:#endif /* STATS_TIME */
    #####:  691:    start_time = stats_time = time( (time_t*) 0 );
    #####:  692:    stats_connections = 0;
    #####:  693:    stats_bytes = 0;
    #####:  694:    stats_simultaneous = 0;
        -:  695:
        -:  696:    /* If we're root, try to become someone else. */
    #####:  697:    if ( getuid() == 0 )
        -:  698:	{
        -:  699:	/* Set aux groups to null. */
    #####:  700:	if ( setgroups( 0, (const gid_t*) 0 ) < 0 )
        -:  701:	    {
    #####:  702:	    syslog( LOG_CRIT, "setgroups - %m" );
    #####:  703:	    exit( 1 );
        -:  704:	    }
        -:  705:	/* Set primary group. */
    #####:  706:	if ( setgid( gid ) < 0 )
        -:  707:	    {
    #####:  708:	    syslog( LOG_CRIT, "setgid - %m" );
    #####:  709:	    exit( 1 );
        -:  710:	    }
        -:  711:	/* Try setting aux groups correctly - not critical if this fails. */
    #####:  712:	if ( initgroups( user, gid ) < 0 )
    #####:  713:	    syslog( LOG_WARNING, "initgroups - %m" );
        -:  714:#ifdef HAVE_SETLOGIN
        -:  715:	/* Set login name. */
        -:  716:        (void) setlogin( user );
        -:  717:#endif /* HAVE_SETLOGIN */
        -:  718:	/* Set uid. */
    #####:  719:	if ( setuid( uid ) < 0 )
        -:  720:	    {
    #####:  721:	    syslog( LOG_CRIT, "setuid - %m" );
    #####:  722:	    exit( 1 );
        -:  723:	    }
        -:  724:	/* Check for unnecessary security exposure. */
    #####:  725:	if ( ! do_chroot )
    #####:  726:	    syslog(
        -:  727:		LOG_WARNING,
        -:  728:		"started as root without requesting chroot(), warning only" );
        -:  729:	}
        -:  730:
        -:  731:    /* Initialize our connections table. */
    #####:  732:    connects = NEW( connecttab, max_connects );
    #####:  733:    if ( connects == (connecttab*) 0 )
        -:  734:	{
    #####:  735:	syslog( LOG_CRIT, "out of memory allocating a connecttab" );
    #####:  736:	exit( 1 );
        -:  737:	}
    #####:  738:    for ( cnum = 0; cnum < max_connects; ++cnum )
        -:  739:	{
    #####:  740:	connects[cnum].conn_state = CNST_FREE;
    #####:  741:	connects[cnum].next_free_connect = cnum + 1;
    #####:  742:	connects[cnum].hc = (httpd_conn*) 0;
        -:  743:	}
    #####:  744:    connects[max_connects - 1].next_free_connect = -1;	/* end of link list */
    #####:  745:    first_free_connect = 0;
    #####:  746:    num_connects = 0;
    #####:  747:    httpd_conn_count = 0;
        -:  748:
    #####:  749:    if ( hs != (httpd_server*) 0 )
        -:  750:	{
    #####:  751:	if ( hs->listen4_fd != -1 )
    #####:  752:	    fdwatch_add_fd( hs->listen4_fd, (void*) 0, FDW_READ );
    #####:  753:	if ( hs->listen6_fd != -1 )
    #####:  754:	    fdwatch_add_fd( hs->listen6_fd, (void*) 0, FDW_READ );
        -:  755:	}
        -:  756:
        -:  757:/*
        -:  758:	//added by shen, SIG handler for terminating server with kill 9 from another terminal
        -:  759: struct sigaction new_action, old_action;
        -:  760:  // setup signal hander 
        -:  761:  new_action.sa_handler = my_handler;
        -:  762:  sigemptyset(&new_action.sa_mask);
        -:  763:  new_action.sa_flags = 0;
        -:  764:  sigaction(SIGUSR1, NULL, &old_action);
        -:  765:  if (old_action.sa_handler != SIG_IGN)
        -:  766:    sigaction (SIGUSR1, &new_action, NULL);
        -:  767:*/
        -:  768:
        -:  769:
        -:  770:    /* Main loop. */
    #####:  771:    (void) gettimeofday( &tv, (struct timezone*) 0 );
    #####:  772:    while ( ( ! terminate ) || num_connects > 0 )
        -:  773:	{
        -:  774:
    #####:  775:	if(count == 40){ 
    #####:  776:	  printf("do handle_usr1\n");
        -:  777:	/* If there are no active connections we want to exit immediately
        -:  778:	** here.  Not only is it faster, but without any connections the
        -:  779:	** main loop won't wake up until the next new connection.
        -:  780:	*/
    #####:  781:	  shut_down();
    #####:  782:	  printf( "exiting" );
    #####:  783:	  closelog();
    #####:  784:          __gcov_flush();
    #####:  785:          printf("after flushing, before exit(0)\n");
    #####:  786:	  exit( 0 );
        -:  787:	}
        -:  788:
        -:  789:
        -:  790:
        -:  791:
        -:  792:
        -:  793:	/* Do we need to re-open the log file? */
    #####:  794:	if ( got_hup )
        -:  795:	    {
    #####:  796:	    re_open_logfile();
    #####:  797:	    got_hup = 0;
        -:  798:	    }
        -:  799:
        -:  800:	/* Do the fd watch. */
    #####:  801:	num_ready = fdwatch( tmr_mstimeout( &tv ) );
    #####:  802:	if ( num_ready < 0 )
        -:  803:	    {
    #####:  804:	    if ( errno == EINTR || errno == EAGAIN )
    #####:  805:		continue;       /* try again */
    #####:  806:	    syslog( LOG_ERR, "fdwatch - %m" );
    #####:  807:	    exit( 1 );
        -:  808:	    }
    #####:  809:	(void) gettimeofday( &tv, (struct timezone*) 0 );
        -:  810:
    #####:  811:	if ( num_ready == 0 )
        -:  812:	    {
        -:  813:	    /* No fd's are ready - run the timers. */
    #####:  814:	    tmr_run( &tv );
    #####:  815:	    continue;
        -:  816:	    }
        -:  817:
        -:  818:	/* Is it a new connection? */
    #####:  819:	if ( hs != (httpd_server*) 0 && hs->listen6_fd != -1 &&
    #####:  820:	     fdwatch_check_fd( hs->listen6_fd ) )
        -:  821:	    {
    #####:  822:	    if ( handle_newconnect( &tv, hs->listen6_fd ) )
        -:  823:		/* Go around the loop and do another fdwatch, rather than
        -:  824:		** dropping through and processing existing connections.
        -:  825:		** New connections always get priority.
        -:  826:		*/
    #####:  827:		continue;
        -:  828:	    }
    #####:  829:	if ( hs != (httpd_server*) 0 && hs->listen4_fd != -1 &&
    #####:  830:	     fdwatch_check_fd( hs->listen4_fd ) )
        -:  831:	    {
    #####:  832:	    if ( handle_newconnect( &tv, hs->listen4_fd ) )
        -:  833:		/* Go around the loop and do another fdwatch, rather than
        -:  834:		** dropping through and processing existing connections.
        -:  835:		** New connections always get priority.
        -:  836:		*/
    #####:  837:		continue;
        -:  838:	    }
        -:  839:
        -:  840:	/* Find the connections that need servicing. */
    #####:  841:	while ( ( c = (connecttab*) fdwatch_get_next_client_data() ) != (connecttab*) -1 )
        -:  842:	    {
    #####:  843:	    if ( c == (connecttab*) 0 )
    #####:  844:		continue;
    #####:  845:	    hc = c->hc;
    #####:  846:	    if ( ! fdwatch_check_fd( hc->conn_fd ) )
        -:  847:		/* Something went wrong. */
    #####:  848:		clear_connection( c, &tv );
        -:  849:	    else
    #####:  850:		switch ( c->conn_state )
        -:  851:		    {
    #####:  852:		    case CNST_READING: handle_read( c, &tv ); break;
    #####:  853:		    case CNST_SENDING: handle_send( c, &tv ); break;
    #####:  854:		    case CNST_LINGERING: handle_linger( c, &tv ); break;
        -:  855:		    }
        -:  856:	    }
        -:  857:
    #####:  858:	printf(" DEBUG before tmr_run...\n");
    #####:  859:	tmr_run( &tv );
    #####:  860:	printf(" DEBUG after tmr_run...\n");
        -:  861:	
        -:  862:	//clear_connection( connecttab* c, struct timeval* tvP );
        -:  863:	//clear_connection( c, &tv ); //added by shen 20180422
    #####:  864:	printf("num_connects: %d count = %d\n", num_connects, count++);
        -:  865://	if(count == 4)
        -:  866://		handle_usr1(SIGUSR1);
        -:  867:
        -:  868:	//terminate = 1;//added by shen
    #####:  869:	if ( got_usr1 && ! terminate )
        -:  870:	    {
        -:  871:	
    #####:  872:	    terminate = 1;
    #####:  873:	    if ( hs != (httpd_server*) 0 )
        -:  874:		{
    #####:  875:		if ( hs->listen4_fd != -1 )
    #####:  876:		    fdwatch_del_fd( hs->listen4_fd );
    #####:  877:		if ( hs->listen6_fd != -1 )
    #####:  878:		    fdwatch_del_fd( hs->listen6_fd );
    #####:  879:		httpd_unlisten( hs );
        -:  880:		}
        -:  881:	    }
    #####:  882:	printf(" DEBUG: still in while loop...");
        -:  883:
        -:  884:	}
        -:  885:	
        -:  886:
        -:  887:    /* The main loop terminated. */
    #####:  888:    shut_down();
    #####:  889:    syslog( LOG_NOTICE, "exiting" );
    #####:  890:    closelog();
    #####:  891:    exit( 0 );
        -:  892:    }
        -:  893:
        -:  894:
        -:  895:static void
        1:  896:parse_args( int argc, char** argv )
        -:  897:    {
        -:  898:    int argn;
        -:  899:
        1:  900:    debug = 0;
        1:  901:    port = DEFAULT_PORT;
        1:  902:    dir = (char*) 0;
        1:  903:    data_dir = (char*) 0;
        -:  904:#ifdef ALWAYS_CHROOT
        -:  905:    do_chroot = 1;
        -:  906:#else /* ALWAYS_CHROOT */
        1:  907:    do_chroot = 0;
        -:  908:#endif /* ALWAYS_CHROOT */
        1:  909:    no_log = 0;
        1:  910:    no_symlink_check = do_chroot;
        -:  911:#ifdef ALWAYS_VHOST
        -:  912:    do_vhost = 1;
        -:  913:#else /* ALWAYS_VHOST */
        1:  914:    do_vhost = 0;
        -:  915:#endif /* ALWAYS_VHOST */
        -:  916:#ifdef ALWAYS_GLOBAL_PASSWD
        -:  917:    do_global_passwd = 1;
        -:  918:#else /* ALWAYS_GLOBAL_PASSWD */
        1:  919:    do_global_passwd = 0;
        -:  920:#endif /* ALWAYS_GLOBAL_PASSWD */
        -:  921:#ifdef CGI_PATTERN
        -:  922:    cgi_pattern = CGI_PATTERN;
        -:  923:#else /* CGI_PATTERN */
        1:  924:    cgi_pattern = (char*) 0;
        -:  925:#endif /* CGI_PATTERN */
        -:  926:#ifdef CGI_LIMIT
        -:  927:    cgi_limit = CGI_LIMIT;
        -:  928:#else /* CGI_LIMIT */
        1:  929:    cgi_limit = 0;
        -:  930:#endif /* CGI_LIMIT */
        1:  931:    url_pattern = (char*) 0;
        1:  932:    no_empty_referrers = 0;
        1:  933:    local_pattern = (char*) 0;
        1:  934:    throttlefile = (char*) 0;
        1:  935:    hostname = (char*) 0;
        1:  936:    logfile = (char*) 0;
        1:  937:    pidfile = (char*) 0;
        1:  938:    user = DEFAULT_USER;
        1:  939:    charset = DEFAULT_CHARSET;
        1:  940:    p3p = "";
        1:  941:    max_age = -1;
        1:  942:    argn = 1;
        3:  943:    while ( argn < argc && argv[argn][0] == '-' )
        -:  944:	{
        1:  945:	if ( strcmp( argv[argn], "-V" ) == 0 )
        -:  946:	    {
    #####:  947:	    (void) printf( "%s\n", SERVER_SOFTWARE );
    #####:  948:	    exit( 0 );
        -:  949:	    }
        1:  950:	else if ( strcmp( argv[argn], "-C" ) == 0 && argn + 1 < argc )
        -:  951:	    {
    #####:  952:	    ++argn;
    #####:  953:	    read_config( argv[argn] );
        -:  954:	    }
        1:  955:	else if ( strcmp( argv[argn], "-p" ) == 0 && argn + 1 < argc )
        -:  956:	    {
    #####:  957:	    ++argn;
    #####:  958:	    port = (unsigned short) atoi( argv[argn] );
        -:  959:	    }
        1:  960:	else if ( strcmp( argv[argn], "-d" ) == 0 && argn + 1 < argc )
        -:  961:	    {
    #####:  962:	    ++argn;
    #####:  963:	    dir = argv[argn];
        -:  964:	    }
        1:  965:	else if ( strcmp( argv[argn], "-r" ) == 0 )
        -:  966:	    {
    #####:  967:	    do_chroot = 1;
    #####:  968:	    no_symlink_check = 1;
        -:  969:	    }
        1:  970:	else if ( strcmp( argv[argn], "-nor" ) == 0 )
        -:  971:	    {
    #####:  972:	    do_chroot = 0;
    #####:  973:	    no_symlink_check = 0;
        -:  974:	    }
        1:  975:	else if ( strcmp( argv[argn], "-dd" ) == 0 && argn + 1 < argc )
        -:  976:	    {
    #####:  977:	    ++argn;
    #####:  978:	    data_dir = argv[argn];
        -:  979:	    }
        1:  980:	else if ( strcmp( argv[argn], "-s" ) == 0 )
    #####:  981:	    no_symlink_check = 0;
        1:  982:	else if ( strcmp( argv[argn], "-nos" ) == 0 )
    #####:  983:	    no_symlink_check = 1;
        1:  984:	else if ( strcmp( argv[argn], "-u" ) == 0 && argn + 1 < argc )
        -:  985:	    {
    #####:  986:	    ++argn;
    #####:  987:	    user = argv[argn];
        -:  988:	    }
        1:  989:	else if ( strcmp( argv[argn], "-c" ) == 0 && argn + 1 < argc )
        -:  990:	    {
    #####:  991:	    ++argn;
    #####:  992:	    cgi_pattern = argv[argn];
        -:  993:	    }
        1:  994:	else if ( strcmp( argv[argn], "-t" ) == 0 && argn + 1 < argc )
        -:  995:	    {
    #####:  996:	    ++argn;
    #####:  997:	    throttlefile = argv[argn];
        -:  998:	    }
        1:  999:	else if ( strcmp( argv[argn], "-h" ) == 0 && argn + 1 < argc )
        -: 1000:	    {
    #####: 1001:	    ++argn;
    #####: 1002:	    hostname = argv[argn];
        -: 1003:	    }
        1: 1004:	else if ( strcmp( argv[argn], "-l" ) == 0 && argn + 1 < argc )
        -: 1005:	    {
    #####: 1006:	    ++argn;
    #####: 1007:	    logfile = argv[argn];
        -: 1008:	    }
        1: 1009:	else if ( strcmp( argv[argn], "-v" ) == 0 )
    #####: 1010:	    do_vhost = 1;
        1: 1011:	else if ( strcmp( argv[argn], "-nov" ) == 0 )
    #####: 1012:	    do_vhost = 0;
        1: 1013:	else if ( strcmp( argv[argn], "-g" ) == 0 )
    #####: 1014:	    do_global_passwd = 1;
        1: 1015:	else if ( strcmp( argv[argn], "-nog" ) == 0 )
    #####: 1016:	    do_global_passwd = 0;
        1: 1017:	else if ( strcmp( argv[argn], "-i" ) == 0 && argn + 1 < argc )
        -: 1018:	    {
    #####: 1019:	    ++argn;
    #####: 1020:	    pidfile = argv[argn];
        -: 1021:	    }
        1: 1022:	else if ( strcmp( argv[argn], "-T" ) == 0 && argn + 1 < argc )
        -: 1023:	    {
    #####: 1024:	    ++argn;
    #####: 1025:	    charset = argv[argn];
        -: 1026:	    }
        1: 1027:	else if ( strcmp( argv[argn], "-P" ) == 0 && argn + 1 < argc )
        -: 1028:	    {
    #####: 1029:	    ++argn;
    #####: 1030:	    p3p = argv[argn];
        -: 1031:	    }
        1: 1032:	else if ( strcmp( argv[argn], "-M" ) == 0 && argn + 1 < argc )
        -: 1033:	    {
    #####: 1034:	    ++argn;
    #####: 1035:	    max_age = atoi( argv[argn] );
        -: 1036:	    }
        1: 1037:	else if ( strcmp( argv[argn], "-D" ) == 0 )
        1: 1038:	    debug = 1;
        -: 1039:	else
    #####: 1040:	    usage();
        1: 1041:	++argn;
        -: 1042:	}
        1: 1043:    if ( argn != argc )
        1: 1044:	usage();
    #####: 1045:    }
        -: 1046:
        -: 1047:
        -: 1048:static void
        1: 1049:usage( void )
        -: 1050:    {
        1: 1051:    (void) fprintf( stderr,
        -: 1052:"usage:  %s [-C configfile] [-p port] [-d dir] [-r|-nor] [-dd data_dir] [-s|-nos] [-v|-nov] [-g|-nog] [-u user] [-c cgipat] [-t throttles] [-h host] [-l logfile] [-i pidfile] [-T charset] [-P P3P] [-M maxage] [-V] [-D]\n",
        -: 1053:	argv0 );
        1: 1054:    exit( 1 );
        -: 1055:    }
        -: 1056:
        -: 1057:
        -: 1058:static void
    #####: 1059:read_config( char* filename )
        -: 1060:    {
        -: 1061:    FILE* fp;
        -: 1062:    char line[10000];
        -: 1063:    char* cp;
        -: 1064:    char* cp2;
        -: 1065:    char* name;
        -: 1066:    char* value;
        -: 1067:
    #####: 1068:    fp = fopen( filename, "r" );
    #####: 1069:    if ( fp == (FILE*) 0 )
        -: 1070:	{
    #####: 1071:	perror( filename );
    #####: 1072:	exit( 1 );
        -: 1073:	}
        -: 1074:
    #####: 1075:    while ( fgets( line, sizeof(line), fp ) != (char*) 0 )
        -: 1076:	{
        -: 1077:	/* Trim comments. */
    #####: 1078:	if ( ( cp = strchr( line, '#' ) ) != (char*) 0 )
    #####: 1079:	    *cp = '\0';
        -: 1080:
        -: 1081:	/* Skip leading whitespace. */
    #####: 1082:	cp = line;
    #####: 1083:	cp += strspn( cp, " \t\n\r" );
        -: 1084:
        -: 1085:	/* Split line into words. */
    #####: 1086:	while ( *cp != '\0' )
        -: 1087:	    {
        -: 1088:	    /* Find next whitespace. */
    #####: 1089:	    cp2 = cp + strcspn( cp, " \t\n\r" );
        -: 1090:	    /* Insert EOS and advance next-word pointer. */
    #####: 1091:	    while ( *cp2 == ' ' || *cp2 == '\t' || *cp2 == '\n' || *cp2 == '\r' )
    #####: 1092:		*cp2++ = '\0';
        -: 1093:	    /* Split into name and value. */
    #####: 1094:	    name = cp;
    #####: 1095:	    value = strchr( name, '=' );
    #####: 1096:	    if ( value != (char*) 0 )
    #####: 1097:		*value++ = '\0';
        -: 1098:	    /* Interpret. */
    #####: 1099:	    if ( strcasecmp( name, "debug" ) == 0 )
        -: 1100:		{
    #####: 1101:		no_value_required( name, value );
    #####: 1102:		debug = 1;
        -: 1103:		}
    #####: 1104:	    else if ( strcasecmp( name, "port" ) == 0 )
        -: 1105:		{
    #####: 1106:		value_required( name, value );
    #####: 1107:		port = (unsigned short) atoi( value );
        -: 1108:		}
    #####: 1109:	    else if ( strcasecmp( name, "dir" ) == 0 )
        -: 1110:		{
    #####: 1111:		value_required( name, value );
    #####: 1112:		dir = e_strdup( value );
        -: 1113:		}
    #####: 1114:	    else if ( strcasecmp( name, "chroot" ) == 0 )
        -: 1115:		{
    #####: 1116:		no_value_required( name, value );
    #####: 1117:		do_chroot = 1;
    #####: 1118:		no_symlink_check = 1;
        -: 1119:		}
    #####: 1120:	    else if ( strcasecmp( name, "nochroot" ) == 0 )
        -: 1121:		{
    #####: 1122:		no_value_required( name, value );
    #####: 1123:		do_chroot = 0;
    #####: 1124:		no_symlink_check = 0;
        -: 1125:		}
    #####: 1126:	    else if ( strcasecmp( name, "data_dir" ) == 0 )
        -: 1127:		{
    #####: 1128:		value_required( name, value );
    #####: 1129:		data_dir = e_strdup( value );
        -: 1130:		}
    #####: 1131:	    else if ( strcasecmp( name, "nosymlinkcheck" ) == 0 )
        -: 1132:		{
    #####: 1133:		no_value_required( name, value );
    #####: 1134:		no_symlink_check = 1;
        -: 1135:		}
    #####: 1136:	    else if ( strcasecmp( name, "symlinkcheck" ) == 0 )
        -: 1137:		{
    #####: 1138:		no_value_required( name, value );
    #####: 1139:		no_symlink_check = 0;
        -: 1140:		}
    #####: 1141:	    else if ( strcasecmp( name, "user" ) == 0 )
        -: 1142:		{
    #####: 1143:		value_required( name, value );
    #####: 1144:		user = e_strdup( value );
        -: 1145:		}
    #####: 1146:	    else if ( strcasecmp( name, "cgipat" ) == 0 )
        -: 1147:		{
    #####: 1148:		value_required( name, value );
    #####: 1149:		cgi_pattern = e_strdup( value );
        -: 1150:		}
    #####: 1151:	    else if ( strcasecmp( name, "cgilimit" ) == 0 )
        -: 1152:		{
    #####: 1153:		value_required( name, value );
    #####: 1154:		cgi_limit = atoi( value );
        -: 1155:		}
    #####: 1156:	    else if ( strcasecmp( name, "urlpat" ) == 0 )
        -: 1157:		{
    #####: 1158:		value_required( name, value );
    #####: 1159:		url_pattern = e_strdup( value );
        -: 1160:		}
    #####: 1161:	    else if ( strcasecmp( name, "noemptyreferers" ) == 0 ||
    #####: 1162:	              strcasecmp( name, "noemptyreferrers" ) == 0 )
        -: 1163:		{
    #####: 1164:		no_value_required( name, value );
    #####: 1165:		no_empty_referrers = 1;
        -: 1166:		}
    #####: 1167:	    else if ( strcasecmp( name, "localpat" ) == 0 )
        -: 1168:		{
    #####: 1169:		value_required( name, value );
    #####: 1170:		local_pattern = e_strdup( value );
        -: 1171:		}
    #####: 1172:	    else if ( strcasecmp( name, "throttles" ) == 0 )
        -: 1173:		{
    #####: 1174:		value_required( name, value );
    #####: 1175:		throttlefile = e_strdup( value );
        -: 1176:		}
    #####: 1177:	    else if ( strcasecmp( name, "host" ) == 0 )
        -: 1178:		{
    #####: 1179:		value_required( name, value );
    #####: 1180:		hostname = e_strdup( value );
        -: 1181:		}
    #####: 1182:	    else if ( strcasecmp( name, "logfile" ) == 0 )
        -: 1183:		{
    #####: 1184:		value_required( name, value );
    #####: 1185:		logfile = e_strdup( value );
        -: 1186:		}
    #####: 1187:	    else if ( strcasecmp( name, "vhost" ) == 0 )
        -: 1188:		{
    #####: 1189:		no_value_required( name, value );
    #####: 1190:		do_vhost = 1;
        -: 1191:		}
    #####: 1192:	    else if ( strcasecmp( name, "novhost" ) == 0 )
        -: 1193:		{
    #####: 1194:		no_value_required( name, value );
    #####: 1195:		do_vhost = 0;
        -: 1196:		}
    #####: 1197:	    else if ( strcasecmp( name, "globalpasswd" ) == 0 )
        -: 1198:		{
    #####: 1199:		no_value_required( name, value );
    #####: 1200:		do_global_passwd = 1;
        -: 1201:		}
    #####: 1202:	    else if ( strcasecmp( name, "noglobalpasswd" ) == 0 )
        -: 1203:		{
    #####: 1204:		no_value_required( name, value );
    #####: 1205:		do_global_passwd = 0;
        -: 1206:		}
    #####: 1207:	    else if ( strcasecmp( name, "pidfile" ) == 0 )
        -: 1208:		{
    #####: 1209:		value_required( name, value );
    #####: 1210:		pidfile = e_strdup( value );
        -: 1211:		}
    #####: 1212:	    else if ( strcasecmp( name, "charset" ) == 0 )
        -: 1213:		{
    #####: 1214:		value_required( name, value );
    #####: 1215:		charset = e_strdup( value );
        -: 1216:		}
    #####: 1217:	    else if ( strcasecmp( name, "p3p" ) == 0 )
        -: 1218:		{
    #####: 1219:		value_required( name, value );
    #####: 1220:		p3p = e_strdup( value );
        -: 1221:		}
    #####: 1222:	    else if ( strcasecmp( name, "max_age" ) == 0 )
        -: 1223:		{
    #####: 1224:		value_required( name, value );
    #####: 1225:		max_age = atoi( value );
        -: 1226:		}
        -: 1227:	    else
        -: 1228:		{
    #####: 1229:		(void) fprintf(
        -: 1230:		    stderr, "%s: unknown config option '%s'\n", argv0, name );
    #####: 1231:		exit( 1 );
        -: 1232:		}
        -: 1233:
        -: 1234:	    /* Advance to next word. */
    #####: 1235:	    cp = cp2;
    #####: 1236:	    cp += strspn( cp, " \t\n\r" );
        -: 1237:	    }
        -: 1238:	}
        -: 1239:
    #####: 1240:    (void) fclose( fp );
    #####: 1241:    }
        -: 1242:
        -: 1243:
        -: 1244:static void
    #####: 1245:value_required( char* name, char* value )
        -: 1246:    {
    #####: 1247:    if ( value == (char*) 0 )
        -: 1248:	{
    #####: 1249:	(void) fprintf(
        -: 1250:	    stderr, "%s: value required for %s option\n", argv0, name );
    #####: 1251:	exit( 1 );
        -: 1252:	}
    #####: 1253:    }
        -: 1254:
        -: 1255:
        -: 1256:static void
    #####: 1257:no_value_required( char* name, char* value )
        -: 1258:    {
    #####: 1259:    if ( value != (char*) 0 )
        -: 1260:	{
    #####: 1261:	(void) fprintf(
        -: 1262:	    stderr, "%s: no value required for %s option\n",
        -: 1263:	    argv0, name );
    #####: 1264:	exit( 1 );
        -: 1265:	}
    #####: 1266:    }
        -: 1267:
        -: 1268:
        -: 1269:static char*
    #####: 1270:e_strdup( char* oldstr )
        -: 1271:    {
        -: 1272:    char* newstr;
        -: 1273:
    #####: 1274:    newstr = strdup( oldstr );
    #####: 1275:    if ( newstr == (char*) 0 )
        -: 1276:	{
    #####: 1277:	syslog( LOG_CRIT, "out of memory copying a string" );
    #####: 1278:	(void) fprintf( stderr, "%s: out of memory copying a string\n", argv0 );
    #####: 1279:	exit( 1 );
        -: 1280:	}
    #####: 1281:    return newstr;
        -: 1282:    }
        -: 1283:
        -: 1284:
        -: 1285:static void
    #####: 1286:lookup_hostname( httpd_sockaddr* sa4P, size_t sa4_len, int* gotv4P, httpd_sockaddr* sa6P, size_t sa6_len, int* gotv6P )
        -: 1287:    {
        -: 1288:#ifdef USE_IPV6
        -: 1289:
        -: 1290:    struct addrinfo hints;
        -: 1291:    char portstr[10];
        -: 1292:    int gaierr;
        -: 1293:    struct addrinfo* ai;
        -: 1294:    struct addrinfo* ai2;
        -: 1295:    struct addrinfo* aiv6;
        -: 1296:    struct addrinfo* aiv4;
        -: 1297:
    #####: 1298:    (void) memset( &hints, 0, sizeof(hints) );
    #####: 1299:    hints.ai_family = PF_UNSPEC;
    #####: 1300:    hints.ai_flags = AI_PASSIVE;
    #####: 1301:    hints.ai_socktype = SOCK_STREAM;
    #####: 1302:    (void) snprintf( portstr, sizeof(portstr), "%d", (int) port );
    #####: 1303:    if ( (gaierr = getaddrinfo( hostname, portstr, &hints, &ai )) != 0 )
        -: 1304:	{
    #####: 1305:	syslog(
        -: 1306:	    LOG_CRIT, "getaddrinfo %.80s - %.80s",
        -: 1307:	    hostname, gai_strerror( gaierr ) );
    #####: 1308:	(void) fprintf(
        -: 1309:	    stderr, "%s: getaddrinfo %s - %s\n",
        -: 1310:	    argv0, hostname, gai_strerror( gaierr ) );
    #####: 1311:	exit( 1 );
        -: 1312:	}
        -: 1313:
        -: 1314:    /* Find the first IPv6 and IPv4 entries. */
    #####: 1315:    aiv6 = (struct addrinfo*) 0;
    #####: 1316:    aiv4 = (struct addrinfo*) 0;
    #####: 1317:    for ( ai2 = ai; ai2 != (struct addrinfo*) 0; ai2 = ai2->ai_next )
        -: 1318:	{
    #####: 1319:	switch ( ai2->ai_family )
        -: 1320:	    {
        -: 1321:	    case AF_INET6:
    #####: 1322:	    if ( aiv6 == (struct addrinfo*) 0 )
    #####: 1323:		aiv6 = ai2;
    #####: 1324:	    break;
        -: 1325:	    case AF_INET:
    #####: 1326:	    if ( aiv4 == (struct addrinfo*) 0 )
    #####: 1327:		aiv4 = ai2;
    #####: 1328:	    break;
        -: 1329:	    }
        -: 1330:	}
        -: 1331:
    #####: 1332:    if ( aiv6 == (struct addrinfo*) 0 )
    #####: 1333:	*gotv6P = 0;
        -: 1334:    else
        -: 1335:	{
    #####: 1336:	if ( sa6_len < aiv6->ai_addrlen )
        -: 1337:	    {
    #####: 1338:	    syslog(
        -: 1339:		LOG_CRIT, "%.80s - sockaddr too small (%lu < %lu)",
        -: 1340:		hostname, (unsigned long) sa6_len,
    #####: 1341:		(unsigned long) aiv6->ai_addrlen );
    #####: 1342:	    exit( 1 );
        -: 1343:	    }
    #####: 1344:	(void) memset( sa6P, 0, sa6_len );
    #####: 1345:	(void) memmove( sa6P, aiv6->ai_addr, aiv6->ai_addrlen );
    #####: 1346:	*gotv6P = 1;
        -: 1347:	}
        -: 1348:
    #####: 1349:    if ( aiv4 == (struct addrinfo*) 0 )
    #####: 1350:	*gotv4P = 0;
        -: 1351:    else
        -: 1352:	{
    #####: 1353:	if ( sa4_len < aiv4->ai_addrlen )
        -: 1354:	    {
    #####: 1355:	    syslog(
        -: 1356:		LOG_CRIT, "%.80s - sockaddr too small (%lu < %lu)",
        -: 1357:		hostname, (unsigned long) sa4_len,
    #####: 1358:		(unsigned long) aiv4->ai_addrlen );
    #####: 1359:	    exit( 1 );
        -: 1360:	    }
    #####: 1361:	(void) memset( sa4P, 0, sa4_len );
    #####: 1362:	(void) memmove( sa4P, aiv4->ai_addr, aiv4->ai_addrlen );
    #####: 1363:	*gotv4P = 1;
        -: 1364:	}
        -: 1365:
    #####: 1366:    freeaddrinfo( ai );
        -: 1367:
        -: 1368:#else /* USE_IPV6 */
        -: 1369:
        -: 1370:    struct hostent* he;
        -: 1371:
        -: 1372:    *gotv6P = 0;
        -: 1373:
        -: 1374:    (void) memset( sa4P, 0, sa4_len );
        -: 1375:    sa4P->sa.sa_family = AF_INET;
        -: 1376:    if ( hostname == (char*) 0 )
        -: 1377:	sa4P->sa_in.sin_addr.s_addr = htonl( INADDR_ANY );
        -: 1378:    else
        -: 1379:	{
        -: 1380:	sa4P->sa_in.sin_addr.s_addr = inet_addr( hostname );
        -: 1381:	if ( (int) sa4P->sa_in.sin_addr.s_addr == -1 )
        -: 1382:	    {
        -: 1383:	    he = gethostbyname( hostname );
        -: 1384:	    if ( he == (struct hostent*) 0 )
        -: 1385:		{
        -: 1386:#ifdef HAVE_HSTRERROR
        -: 1387:		syslog(
        -: 1388:		    LOG_CRIT, "gethostbyname %.80s - %.80s",
        -: 1389:		    hostname, hstrerror( h_errno ) );
        -: 1390:		(void) fprintf(
        -: 1391:		    stderr, "%s: gethostbyname %s - %s\n",
        -: 1392:		    argv0, hostname, hstrerror( h_errno ) );
        -: 1393:#else /* HAVE_HSTRERROR */
        -: 1394:		syslog( LOG_CRIT, "gethostbyname %.80s failed", hostname );
        -: 1395:		(void) fprintf(
        -: 1396:		    stderr, "%s: gethostbyname %s failed\n", argv0, hostname );
        -: 1397:#endif /* HAVE_HSTRERROR */
        -: 1398:		exit( 1 );
        -: 1399:		}
        -: 1400:	    if ( he->h_addrtype != AF_INET )
        -: 1401:		{
        -: 1402:		syslog( LOG_CRIT, "%.80s - non-IP network address", hostname );
        -: 1403:		(void) fprintf(
        -: 1404:		    stderr, "%s: %s - non-IP network address\n",
        -: 1405:		    argv0, hostname );
        -: 1406:		exit( 1 );
        -: 1407:		}
        -: 1408:	    (void) memmove(
        -: 1409:		&sa4P->sa_in.sin_addr.s_addr, he->h_addr, he->h_length );
        -: 1410:	    }
        -: 1411:	}
        -: 1412:    sa4P->sa_in.sin_port = htons( port );
        -: 1413:    *gotv4P = 1;
        -: 1414:
        -: 1415:#endif /* USE_IPV6 */
    #####: 1416:    }
        -: 1417:
        -: 1418:
        -: 1419:static void
    #####: 1420:read_throttlefile( char* tf )
        -: 1421:    {
        -: 1422:    FILE* fp;
        -: 1423:    char buf[5000];
        -: 1424:    char* cp;
        -: 1425:    int len;
        -: 1426:    char pattern[5000];
        -: 1427:    long max_limit, min_limit;
        -: 1428:    struct timeval tv;
        -: 1429:
    #####: 1430:    fp = fopen( tf, "r" );
    #####: 1431:    if ( fp == (FILE*) 0 )
        -: 1432:	{
    #####: 1433:	syslog( LOG_CRIT, "%.80s - %m", tf );
    #####: 1434:	perror( tf );
    #####: 1435:	exit( 1 );
        -: 1436:	}
        -: 1437:
    #####: 1438:    (void) gettimeofday( &tv, (struct timezone*) 0 );
        -: 1439:
    #####: 1440:    while ( fgets( buf, sizeof(buf), fp ) != (char*) 0 )
        -: 1441:	{
        -: 1442:	/* Nuke comments. */
    #####: 1443:	cp = strchr( buf, '#' );
    #####: 1444:	if ( cp != (char*) 0 )
    #####: 1445:	    *cp = '\0';
        -: 1446:
        -: 1447:	/* Nuke trailing whitespace. */
    #####: 1448:	len = strlen( buf );
    #####: 1449:	while ( len > 0 &&
    #####: 1450:		( buf[len-1] == ' ' || buf[len-1] == '\t' ||
    #####: 1451:		  buf[len-1] == '\n' || buf[len-1] == '\r' ) )
    #####: 1452:	    buf[--len] = '\0';
        -: 1453:
        -: 1454:	/* Ignore empty lines. */
    #####: 1455:	if ( len == 0 )
    #####: 1456:	    continue;
        -: 1457:
        -: 1458:	/* Parse line. */
    #####: 1459:	if ( sscanf( buf, " %4900[^ \t] %ld-%ld", pattern, &min_limit, &max_limit ) == 3 )
        -: 1460:	    {}
    #####: 1461:	else if ( sscanf( buf, " %4900[^ \t] %ld", pattern, &max_limit ) == 2 )
    #####: 1462:	    min_limit = 0;
        -: 1463:	else
        -: 1464:	    {
    #####: 1465:	    syslog( LOG_CRIT,
        -: 1466:		"unparsable line in %.80s - %.80s", tf, buf );
    #####: 1467:	    (void) fprintf( stderr,
        -: 1468:		"%s: unparsable line in %.80s - %.80s\n",
        -: 1469:		argv0, tf, buf );
    #####: 1470:	    continue;
        -: 1471:	    }
        -: 1472:
        -: 1473:	/* Nuke any leading slashes in pattern. */
    #####: 1474:	if ( pattern[0] == '/' )
    #####: 1475:	    (void) ol_strcpy( pattern, &pattern[1] );
    #####: 1476:	while ( ( cp = strstr( pattern, "|/" ) ) != (char*) 0 )
    #####: 1477:	    (void) ol_strcpy( cp + 1, cp + 2 );
        -: 1478:
        -: 1479:	/* Check for room in throttles. */
    #####: 1480:	if ( numthrottles >= maxthrottles )
        -: 1481:	    {
    #####: 1482:	    if ( maxthrottles == 0 )
        -: 1483:		{
    #####: 1484:		maxthrottles = 100;     /* arbitrary */
    #####: 1485:		throttles = NEW( throttletab, maxthrottles );
        -: 1486:		}
        -: 1487:	    else
        -: 1488:		{
    #####: 1489:		maxthrottles *= 2;
    #####: 1490:		throttles = RENEW( throttles, throttletab, maxthrottles );
        -: 1491:		}
    #####: 1492:	    if ( throttles == (throttletab*) 0 )
        -: 1493:		{
    #####: 1494:		syslog( LOG_CRIT, "out of memory allocating a throttletab" );
    #####: 1495:		(void) fprintf(
        -: 1496:		    stderr, "%s: out of memory allocating a throttletab\n",
        -: 1497:		    argv0 );
    #####: 1498:		exit( 1 );
        -: 1499:		}
        -: 1500:	    }
        -: 1501:
        -: 1502:	/* Add to table. */
    #####: 1503:	throttles[numthrottles].pattern = e_strdup( pattern );
    #####: 1504:	throttles[numthrottles].max_limit = max_limit;
    #####: 1505:	throttles[numthrottles].min_limit = min_limit;
    #####: 1506:	throttles[numthrottles].rate = 0;
    #####: 1507:	throttles[numthrottles].bytes_since_avg = 0;
    #####: 1508:	throttles[numthrottles].num_sending = 0;
        -: 1509:
    #####: 1510:	++numthrottles;
        -: 1511:	}
    #####: 1512:    (void) fclose( fp );
    #####: 1513:    }
        -: 1514:
        -: 1515:
        -: 1516:static void
    #####: 1517:shut_down( void )
        -: 1518:    {
        -: 1519:    int cnum;
        -: 1520:    struct timeval tv;
        -: 1521:
    #####: 1522:    (void) gettimeofday( &tv, (struct timezone*) 0 );
    #####: 1523:    logstats( &tv );
    #####: 1524:    for ( cnum = 0; cnum < max_connects; ++cnum )
        -: 1525:	{
    #####: 1526:	if ( connects[cnum].conn_state != CNST_FREE )
    #####: 1527:	    httpd_close_conn( connects[cnum].hc, &tv );
    #####: 1528:	if ( connects[cnum].hc != (httpd_conn*) 0 )
        -: 1529:	    {
    #####: 1530:	    httpd_destroy_conn( connects[cnum].hc );
    #####: 1531:	    free( (void*) connects[cnum].hc );
    #####: 1532:	    --httpd_conn_count;
    #####: 1533:	    connects[cnum].hc = (httpd_conn*) 0;
        -: 1534:	    }
        -: 1535:	}
    #####: 1536:    if ( hs != (httpd_server*) 0 )
        -: 1537:	{
    #####: 1538:	httpd_server* ths = hs;
    #####: 1539:	hs = (httpd_server*) 0;
    #####: 1540:	if ( ths->listen4_fd != -1 )
    #####: 1541:	    fdwatch_del_fd( ths->listen4_fd );
    #####: 1542:	if ( ths->listen6_fd != -1 )
    #####: 1543:	    fdwatch_del_fd( ths->listen6_fd );
    #####: 1544:	httpd_terminate( ths );
        -: 1545:	}
    #####: 1546:    mmc_term();
    #####: 1547:    tmr_term();
    #####: 1548:    free( (void*) connects );
    #####: 1549:    if ( throttles != (throttletab*) 0 )
    #####: 1550:	free( (void*) throttles );
    #####: 1551:    }
        -: 1552:
        -: 1553:
        -: 1554:static int
    #####: 1555:handle_newconnect( struct timeval* tvP, int listen_fd )
        -: 1556:    {
        -: 1557:    connecttab* c;
        -: 1558:    ClientData client_data;
        -: 1559:
        -: 1560:    /* This loops until the accept() fails, trying to start new
        -: 1561:    ** connections as fast as possible so we don't overrun the
        -: 1562:    ** listen queue.
        -: 1563:    */
        -: 1564:    for (;;)
        -: 1565:	{
        -: 1566:	/* Is there room in the connection table? */
    #####: 1567:	if ( num_connects >= max_connects )
        -: 1568:	    {
        -: 1569:	    /* Out of connection slots.  Run the timers, then the
        -: 1570:	    ** existing connections, and maybe we'll free up a slot
        -: 1571:	    ** by the time we get back here.
        -: 1572:	    */
    #####: 1573:	    syslog( LOG_WARNING, "too many connections!" );
    #####: 1574:	    tmr_run( tvP );
    #####: 1575:	    return 0;
        -: 1576:	    }
        -: 1577:	/* Get the first free connection entry off the free list. */
    #####: 1578:	if ( first_free_connect == -1 || connects[first_free_connect].conn_state != CNST_FREE )
        -: 1579:	    {
    #####: 1580:	    syslog( LOG_CRIT, "the connects free list is messed up" );
    #####: 1581:	    exit( 1 );
        -: 1582:	    }
    #####: 1583:	c = &connects[first_free_connect];
        -: 1584:	/* Make the httpd_conn if necessary. */
    #####: 1585:	if ( c->hc == (httpd_conn*) 0 )
        -: 1586:	    {
    #####: 1587:	    c->hc = NEW( httpd_conn, 1 );
    #####: 1588:	    if ( c->hc == (httpd_conn*) 0 )
        -: 1589:		{
    #####: 1590:		syslog( LOG_CRIT, "out of memory allocating an httpd_conn" );
    #####: 1591:		exit( 1 );
        -: 1592:		}
    #####: 1593:	    c->hc->initialized = 0;
    #####: 1594:	    ++httpd_conn_count;
        -: 1595:	    }
        -: 1596:
        -: 1597:	/* Get the connection. */
    #####: 1598:	switch ( httpd_get_conn( hs, listen_fd, c->hc ) )
        -: 1599:	    {
        -: 1600:	    /* Some error happened.  Run the timers, then the
        -: 1601:	    ** existing connections.  Maybe the error will clear.
        -: 1602:	    */
        -: 1603:	    case GC_FAIL:
    #####: 1604:	    tmr_run( tvP );
    #####: 1605:	    return 0;
        -: 1606:
        -: 1607:	    /* No more connections to accept for now. */
        -: 1608:	    case GC_NO_MORE:
    #####: 1609:	    return 1;
        -: 1610:	    }
    #####: 1611:	c->conn_state = CNST_READING;
        -: 1612:	/* Pop it off the free list. */
    #####: 1613:	first_free_connect = c->next_free_connect;
    #####: 1614:	c->next_free_connect = -1;
    #####: 1615:	++num_connects;
    #####: 1616:	client_data.p = c;
    #####: 1617:	c->active_at = tvP->tv_sec;
    #####: 1618:	c->wakeup_timer = (Timer*) 0;
    #####: 1619:	c->linger_timer = (Timer*) 0;
    #####: 1620:	c->next_byte_index = 0;
    #####: 1621:	c->numtnums = 0;
        -: 1622:
        -: 1623:	/* Set the connection file descriptor to no-delay mode. */
    #####: 1624:	httpd_set_ndelay( c->hc->conn_fd );
        -: 1625:
    #####: 1626:	fdwatch_add_fd( c->hc->conn_fd, c, FDW_READ );
        -: 1627:
    #####: 1628:	++stats_connections;
    #####: 1629:	if ( num_connects > stats_simultaneous )
    #####: 1630:	    stats_simultaneous = num_connects;
    #####: 1631:	}
        -: 1632:    }
        -: 1633:
        -: 1634:
        -: 1635:static void
    #####: 1636:handle_read( connecttab* c, struct timeval* tvP )
        -: 1637:    {
        -: 1638:    int sz;
        -: 1639:    ClientData client_data;
    #####: 1640:    httpd_conn* hc = c->hc;
        -: 1641:
        -: 1642:    /* Is there room in our buffer to read more bytes? */
    #####: 1643:    if ( hc->read_idx >= hc->read_size )
        -: 1644:	{
    #####: 1645:	if ( hc->read_size > 5000 )
        -: 1646:	    {
    #####: 1647:	    httpd_send_err( hc, 400, httpd_err400title, "", httpd_err400form, "" );
    #####: 1648:	    finish_connection( c, tvP );
    #####: 1649:	    return;
        -: 1650:	    }
    #####: 1651:	httpd_realloc_str(
    #####: 1652:	    &hc->read_buf, &hc->read_size, hc->read_size + 1000 );
        -: 1653:	}
        -: 1654:
        -: 1655:    /* Read some more bytes. */
    #####: 1656:    sz = read(
    #####: 1657:	hc->conn_fd, &(hc->read_buf[hc->read_idx]),
    #####: 1658:	hc->read_size - hc->read_idx );
    #####: 1659:    if ( sz == 0 )
        -: 1660:	{
    #####: 1661:	httpd_send_err( hc, 400, httpd_err400title, "", httpd_err400form, "" );
    #####: 1662:	finish_connection( c, tvP );
    #####: 1663:	return;
        -: 1664:	}
    #####: 1665:    if ( sz < 0 )
        -: 1666:	{
        -: 1667:	/* Ignore EINTR and EAGAIN.  Also ignore EWOULDBLOCK.  At first glance
        -: 1668:	** you would think that connections returned by fdwatch as readable
        -: 1669:	** should never give an EWOULDBLOCK; however, this apparently can
        -: 1670:	** happen if a packet gets garbled.
        -: 1671:	*/
    #####: 1672:	if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK )
    #####: 1673:	    return;
    #####: 1674:	httpd_send_err(
        -: 1675:	    hc, 400, httpd_err400title, "", httpd_err400form, "" );
    #####: 1676:	finish_connection( c, tvP );
    #####: 1677:	return;
        -: 1678:	}
    #####: 1679:    hc->read_idx += sz;
    #####: 1680:    c->active_at = tvP->tv_sec;
        -: 1681:
        -: 1682:    /* Do we have a complete request yet? */
    #####: 1683:    switch ( httpd_got_request( hc ) )
        -: 1684:	{
        -: 1685:	case GR_NO_REQUEST:
    #####: 1686:	return;
        -: 1687:	case GR_BAD_REQUEST:
    #####: 1688:	httpd_send_err( hc, 400, httpd_err400title, "", httpd_err400form, "" );
    #####: 1689:	finish_connection( c, tvP );
    #####: 1690:	return;
        -: 1691:	}
        -: 1692:
        -: 1693:    /* Yes.  Try parsing and resolving it. */
    #####: 1694:    if ( httpd_parse_request( hc ) < 0 )
        -: 1695:	{
    #####: 1696:	finish_connection( c, tvP );
    #####: 1697:	return;
        -: 1698:	}
        -: 1699:
        -: 1700:    /* Check the throttle table */
    #####: 1701:    if ( ! check_throttles( c ) )
        -: 1702:	{
    #####: 1703:	httpd_send_err(
        -: 1704:	    hc, 503, httpd_err503title, "", httpd_err503form, hc->encodedurl );
    #####: 1705:	finish_connection( c, tvP );
    #####: 1706:	return;
        -: 1707:	}
        -: 1708:
        -: 1709:    /* Start the connection going. */
    #####: 1710:    if ( httpd_start_request( hc, tvP ) < 0 )
        -: 1711:	{
        -: 1712:	/* Something went wrong.  Close down the connection. */
    #####: 1713:	finish_connection( c, tvP );
    #####: 1714:	return;
        -: 1715:	}
        -: 1716:
        -: 1717:    /* Fill in end_byte_index. */
    #####: 1718:    if ( hc->got_range )
        -: 1719:	{
    #####: 1720:	c->next_byte_index = hc->first_byte_index;
    #####: 1721:	c->end_byte_index = hc->last_byte_index + 1;
        -: 1722:	}
    #####: 1723:    else if ( hc->bytes_to_send < 0 )
    #####: 1724:	c->end_byte_index = 0;
        -: 1725:    else
    #####: 1726:	c->end_byte_index = hc->bytes_to_send;
        -: 1727:
        -: 1728:    /* Check if it's already handled. */
    #####: 1729:    if ( hc->file_address == (char*) 0 )
        -: 1730:	{
        -: 1731:	/* No file address means someone else is handling it. */
        -: 1732:	int tind;
    #####: 1733:	for ( tind = 0; tind < c->numtnums; ++tind )
    #####: 1734:	    throttles[c->tnums[tind]].bytes_since_avg += hc->bytes_sent;
    #####: 1735:	c->next_byte_index = hc->bytes_sent;
    #####: 1736:	finish_connection( c, tvP );
    #####: 1737:	return;
        -: 1738:	}
    #####: 1739:    if ( c->next_byte_index >= c->end_byte_index )
        -: 1740:	{
        -: 1741:	/* There's nothing to send. */
    #####: 1742:	finish_connection( c, tvP );
    #####: 1743:	return;
        -: 1744:	}
        -: 1745:
        -: 1746:    /* Cool, we have a valid connection and a file to send to it. */
    #####: 1747:    c->conn_state = CNST_SENDING;
    #####: 1748:    c->started_at = tvP->tv_sec;
    #####: 1749:    c->wouldblock_delay = 0;
    #####: 1750:    client_data.p = c;
        -: 1751:
    #####: 1752:    fdwatch_del_fd( hc->conn_fd );
    #####: 1753:    fdwatch_add_fd( hc->conn_fd, c, FDW_WRITE );
        -: 1754:    }
        -: 1755:
        -: 1756:
        -: 1757:static void
    #####: 1758:handle_send( connecttab* c, struct timeval* tvP )
        -: 1759:    {
        -: 1760:    size_t max_bytes;
        -: 1761:    int sz, coast;
        -: 1762:    ClientData client_data;
        -: 1763:    time_t elapsed;
    #####: 1764:    httpd_conn* hc = c->hc;
        -: 1765:    int tind;
        -: 1766:
    #####: 1767:    if ( c->max_limit == THROTTLE_NOLIMIT )
    #####: 1768:	max_bytes = 1000000000L;
        -: 1769:    else
    #####: 1770:	max_bytes = c->max_limit / 4;	/* send at most 1/4 seconds worth */
        -: 1771:
        -: 1772:    /* Do we need to write the headers first? */
    #####: 1773:    if ( hc->responselen == 0 )
        -: 1774:	{
        -: 1775:	/* No, just write the file. */
    #####: 1776:	sz = write(
    #####: 1777:	    hc->conn_fd, &(hc->file_address[c->next_byte_index]),
    #####: 1778:	    MIN( c->end_byte_index - c->next_byte_index, max_bytes ) );
        -: 1779:	}
        -: 1780:    else
        -: 1781:	{
        -: 1782:	/* Yes.  We'll combine headers and file into a single writev(),
        -: 1783:	** hoping that this generates a single packet.
        -: 1784:	*/
        -: 1785:	struct iovec iv[2];
        -: 1786:
    #####: 1787:	iv[0].iov_base = hc->response;
    #####: 1788:	iv[0].iov_len = hc->responselen;
    #####: 1789:	iv[1].iov_base = &(hc->file_address[c->next_byte_index]);
    #####: 1790:	iv[1].iov_len = MIN( c->end_byte_index - c->next_byte_index, max_bytes );
    #####: 1791:	sz = writev( hc->conn_fd, iv, 2 );
        -: 1792:	}
        -: 1793:
    #####: 1794:    if ( sz < 0 && errno == EINTR )
    #####: 1795:	return;
        -: 1796:
    #####: 1797:    if ( sz == 0 ||
    #####: 1798:	 ( sz < 0 && ( errno == EWOULDBLOCK || errno == EAGAIN ) ) )
        -: 1799:	{
        -: 1800:	/* This shouldn't happen, but some kernels, e.g.
        -: 1801:	** SunOS 4.1.x, are broken and select() says that
        -: 1802:	** O_NDELAY sockets are always writable even when
        -: 1803:	** they're actually not.
        -: 1804:	**
        -: 1805:	** Current workaround is to block sending on this
        -: 1806:	** socket for a brief adaptively-tuned period.
        -: 1807:	** Fortunately we already have all the necessary
        -: 1808:	** blocking code, for use with throttling.
        -: 1809:	*/
    #####: 1810:	c->wouldblock_delay += MIN_WOULDBLOCK_DELAY;
    #####: 1811:	c->conn_state = CNST_PAUSING;
    #####: 1812:	fdwatch_del_fd( hc->conn_fd );
    #####: 1813:	client_data.p = c;
    #####: 1814:	if ( c->wakeup_timer != (Timer*) 0 )
    #####: 1815:	    syslog( LOG_ERR, "replacing non-null wakeup_timer!" );
    #####: 1816:	c->wakeup_timer = tmr_create(
        -: 1817:	    tvP, wakeup_connection, client_data, c->wouldblock_delay, 0 );
    #####: 1818:	if ( c->wakeup_timer == (Timer*) 0 )
        -: 1819:	    {
    #####: 1820:	    syslog( LOG_CRIT, "tmr_create(wakeup_connection) failed" );
    #####: 1821:	    exit( 1 );
        -: 1822:	    }
    #####: 1823:	return;
        -: 1824:	}
        -: 1825:
    #####: 1826:    if ( sz < 0 )
        -: 1827:	{
        -: 1828:	/* Something went wrong, close this connection.
        -: 1829:	**
        -: 1830:	** If it's just an EPIPE, don't bother logging, that
        -: 1831:	** just means the client hung up on us.
        -: 1832:	**
        -: 1833:	** On some systems, write() occasionally gives an EINVAL.
        -: 1834:	** Dunno why, something to do with the socket going
        -: 1835:	** bad.  Anyway, we don't log those either.
        -: 1836:	**
        -: 1837:	** And ECONNRESET isn't interesting either.
        -: 1838:	*/
    #####: 1839:	if ( errno != EPIPE && errno != EINVAL && errno != ECONNRESET )
    #####: 1840:	    syslog( LOG_ERR, "write - %m sending %.80s", hc->encodedurl );
    #####: 1841:	clear_connection( c, tvP );
    #####: 1842:	return;
        -: 1843:	}
        -: 1844:
        -: 1845:    /* Ok, we wrote something. */
    #####: 1846:    c->active_at = tvP->tv_sec;
        -: 1847:    /* Was this a headers + file writev()? */
    #####: 1848:    if ( hc->responselen > 0 )
        -: 1849:	{
        -: 1850:	/* Yes; did we write only part of the headers? */
    #####: 1851:	if ( sz < hc->responselen )
        -: 1852:	    {
        -: 1853:	    /* Yes; move the unwritten part to the front of the buffer. */
    #####: 1854:	    int newlen = hc->responselen - sz;
    #####: 1855:	    (void) memmove( hc->response, &(hc->response[sz]), newlen );
    #####: 1856:	    hc->responselen = newlen;
    #####: 1857:	    sz = 0;
        -: 1858:	    }
        -: 1859:	else
        -: 1860:	    {
        -: 1861:	    /* Nope, we wrote the full headers, so adjust accordingly. */
    #####: 1862:	    sz -= hc->responselen;
    #####: 1863:	    hc->responselen = 0;
        -: 1864:	    }
        -: 1865:	}
        -: 1866:    /* And update how much of the file we wrote. */
    #####: 1867:    c->next_byte_index += sz;
    #####: 1868:    c->hc->bytes_sent += sz;
    #####: 1869:    for ( tind = 0; tind < c->numtnums; ++tind )
    #####: 1870:	throttles[c->tnums[tind]].bytes_since_avg += sz;
        -: 1871:
        -: 1872:    /* Are we done? */
    #####: 1873:    if ( c->next_byte_index >= c->end_byte_index )
        -: 1874:	{
        -: 1875:	/* This connection is finished! */
    #####: 1876:	finish_connection( c, tvP );
    #####: 1877:	return;
        -: 1878:	}
        -: 1879:
        -: 1880:    /* Tune the (blockheaded) wouldblock delay. */
    #####: 1881:    if ( c->wouldblock_delay > MIN_WOULDBLOCK_DELAY )
    #####: 1882:	c->wouldblock_delay -= MIN_WOULDBLOCK_DELAY;
        -: 1883:
        -: 1884:    /* If we're throttling, check if we're sending too fast. */
    #####: 1885:    if ( c->max_limit != THROTTLE_NOLIMIT )
        -: 1886:	{
    #####: 1887:	elapsed = tvP->tv_sec - c->started_at;
    #####: 1888:	if ( elapsed == 0 )
    #####: 1889:	    elapsed = 1;	/* count at least one second */
    #####: 1890:	if ( c->hc->bytes_sent / elapsed > c->max_limit )
        -: 1891:	    {
    #####: 1892:	    c->conn_state = CNST_PAUSING;
    #####: 1893:	    fdwatch_del_fd( hc->conn_fd );
        -: 1894:	    /* How long should we wait to get back on schedule?  If less
        -: 1895:	    ** than a second (integer math rounding), use 1/2 second.
        -: 1896:	    */
    #####: 1897:	    coast = c->hc->bytes_sent / c->max_limit - elapsed;
    #####: 1898:	    client_data.p = c;
    #####: 1899:	    if ( c->wakeup_timer != (Timer*) 0 )
    #####: 1900:		syslog( LOG_ERR, "replacing non-null wakeup_timer!" );
    #####: 1901:	    c->wakeup_timer = tmr_create(
        -: 1902:		tvP, wakeup_connection, client_data,
        -: 1903:		coast > 0 ? ( coast * 1000L ) : 500L, 0 );
    #####: 1904:	    if ( c->wakeup_timer == (Timer*) 0 )
        -: 1905:		{
    #####: 1906:		syslog( LOG_CRIT, "tmr_create(wakeup_connection) failed" );
    #####: 1907:		exit( 1 );
        -: 1908:		}
        -: 1909:	    }
        -: 1910:	}
        -: 1911:    /* (No check on min_limit here, that only controls connection startups.) */
        -: 1912:    }
        -: 1913:
        -: 1914:
        -: 1915:static void
    #####: 1916:handle_linger( connecttab* c, struct timeval* tvP )
        -: 1917:    {
        -: 1918:    char buf[4096];
        -: 1919:    int r;
        -: 1920:
        -: 1921:    /* In lingering-close mode we just read and ignore bytes.  An error
        -: 1922:    ** or EOF ends things, otherwise we go until a timeout.
        -: 1923:    */
    #####: 1924:    r = read( c->hc->conn_fd, buf, sizeof(buf) );
    #####: 1925:    if ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )
    #####: 1926:	return;
    #####: 1927:    if ( r <= 0 )
    #####: 1928:	really_clear_connection( c, tvP );
        -: 1929:    }
        -: 1930:
        -: 1931:
        -: 1932:static int
    #####: 1933:check_throttles( connecttab* c )
        -: 1934:    {
        -: 1935:    int tnum;
        -: 1936:    long l;
        -: 1937:
    #####: 1938:    c->numtnums = 0;
    #####: 1939:    c->max_limit = c->min_limit = THROTTLE_NOLIMIT;
    #####: 1940:    for ( tnum = 0; tnum < numthrottles && c->numtnums < MAXTHROTTLENUMS;
    #####: 1941:	  ++tnum )
    #####: 1942:	if ( match( throttles[tnum].pattern, c->hc->expnfilename ) )
        -: 1943:	    {
        -: 1944:	    /* If we're way over the limit, don't even start. */
    #####: 1945:	    if ( throttles[tnum].rate > throttles[tnum].max_limit * 2 )
    #####: 1946:		return 0;
        -: 1947:	    /* Also don't start if we're under the minimum. */
    #####: 1948:	    if ( throttles[tnum].rate < throttles[tnum].min_limit )
    #####: 1949:		return 0;
    #####: 1950:	    if ( throttles[tnum].num_sending < 0 )
        -: 1951:		{
    #####: 1952:		syslog( LOG_ERR, "throttle sending count was negative - shouldn't happen!" );
    #####: 1953:		throttles[tnum].num_sending = 0;
        -: 1954:		}
    #####: 1955:	    c->tnums[c->numtnums++] = tnum;
    #####: 1956:	    ++throttles[tnum].num_sending;
    #####: 1957:	    l = throttles[tnum].max_limit / throttles[tnum].num_sending;
    #####: 1958:	    if ( c->max_limit == THROTTLE_NOLIMIT )
    #####: 1959:		c->max_limit = l;
        -: 1960:	    else
    #####: 1961:		c->max_limit = MIN( c->max_limit, l );
    #####: 1962:	    l = throttles[tnum].min_limit;
    #####: 1963:	    if ( c->min_limit == THROTTLE_NOLIMIT )
    #####: 1964:		c->min_limit = l;
        -: 1965:	    else
    #####: 1966:		c->min_limit = MAX( c->min_limit, l );
        -: 1967:	    }
    #####: 1968:    return 1;
        -: 1969:    }
        -: 1970:
        -: 1971:
        -: 1972:static void
    #####: 1973:clear_throttles( connecttab* c, struct timeval* tvP )
        -: 1974:    {
        -: 1975:    int tind;
        -: 1976:
    #####: 1977:    for ( tind = 0; tind < c->numtnums; ++tind )
    #####: 1978:	--throttles[c->tnums[tind]].num_sending;
    #####: 1979:    }
        -: 1980:
        -: 1981:
        -: 1982:static void
    #####: 1983:update_throttles( ClientData client_data, struct timeval* nowP )
        -: 1984:    {
        -: 1985:    int tnum, tind;
        -: 1986:    int cnum;
        -: 1987:    connecttab* c;
        -: 1988:    long l;
        -: 1989:
        -: 1990:    /* Update the average sending rate for each throttle.  This is only used
        -: 1991:    ** when new connections start up.
        -: 1992:    */
    #####: 1993:    for ( tnum = 0; tnum < numthrottles; ++tnum )
        -: 1994:	{
    #####: 1995:	throttles[tnum].rate = ( 2 * throttles[tnum].rate + throttles[tnum].bytes_since_avg / THROTTLE_TIME ) / 3;
    #####: 1996:	throttles[tnum].bytes_since_avg = 0;
        -: 1997:	/* Log a warning message if necessary. */
    #####: 1998:	if ( throttles[tnum].rate > throttles[tnum].max_limit && throttles[tnum].num_sending != 0 )
        -: 1999:	    {
    #####: 2000:	    if ( throttles[tnum].rate > throttles[tnum].max_limit * 2 )
    #####: 2001:		syslog( LOG_NOTICE, "throttle #%d '%.80s' rate %ld greatly exceeding limit %ld; %d sending", tnum, throttles[tnum].pattern, throttles[tnum].rate, throttles[tnum].max_limit, throttles[tnum].num_sending );
        -: 2002:	    else
    #####: 2003:		syslog( LOG_INFO, "throttle #%d '%.80s' rate %ld exceeding limit %ld; %d sending", tnum, throttles[tnum].pattern, throttles[tnum].rate, throttles[tnum].max_limit, throttles[tnum].num_sending );
        -: 2004:	    }
    #####: 2005:	if ( throttles[tnum].rate < throttles[tnum].min_limit && throttles[tnum].num_sending != 0 )
        -: 2006:	    {
    #####: 2007:	    syslog( LOG_NOTICE, "throttle #%d '%.80s' rate %ld lower than minimum %ld; %d sending", tnum, throttles[tnum].pattern, throttles[tnum].rate, throttles[tnum].min_limit, throttles[tnum].num_sending );
        -: 2008:	    }
        -: 2009:	}
        -: 2010:
        -: 2011:    /* Now update the sending rate on all the currently-sending connections,
        -: 2012:    ** redistributing it evenly.
        -: 2013:    */
    #####: 2014:    for ( cnum = 0; cnum < max_connects; ++cnum )
        -: 2015:	{
    #####: 2016:	c = &connects[cnum];
    #####: 2017:	if ( c->conn_state == CNST_SENDING || c->conn_state == CNST_PAUSING )
        -: 2018:	    {
    #####: 2019:	    c->max_limit = THROTTLE_NOLIMIT;
    #####: 2020:	    for ( tind = 0; tind < c->numtnums; ++tind )
        -: 2021:		{
    #####: 2022:		tnum = c->tnums[tind];
    #####: 2023:		l = throttles[tnum].max_limit / throttles[tnum].num_sending;
    #####: 2024:		if ( c->max_limit == THROTTLE_NOLIMIT )
    #####: 2025:		    c->max_limit = l;
        -: 2026:		else
    #####: 2027:		    c->max_limit = MIN( c->max_limit, l );
        -: 2028:		}
        -: 2029:	    }
        -: 2030:	}
    #####: 2031:    }
        -: 2032:
        -: 2033:
        -: 2034:static void
    #####: 2035:finish_connection( connecttab* c, struct timeval* tvP )
        -: 2036:    {
        -: 2037:    /* If we haven't actually sent the buffered response yet, do so now. */
    #####: 2038:    httpd_write_response( c->hc );
        -: 2039:
        -: 2040:    /* And clear. */
    #####: 2041:    clear_connection( c, tvP );
    #####: 2042:    }
        -: 2043:
        -: 2044:
        -: 2045:static void
    #####: 2046:clear_connection( connecttab* c, struct timeval* tvP )
        -: 2047:    {
        -: 2048:    ClientData client_data;
        -: 2049:
    #####: 2050:    if ( c->wakeup_timer != (Timer*) 0 )
        -: 2051:	{
    #####: 2052:	tmr_cancel( c->wakeup_timer );
    #####: 2053:	c->wakeup_timer = 0;
        -: 2054:	}
        -: 2055:
        -: 2056:    /* This is our version of Apache's lingering_close() routine, which is
        -: 2057:    ** their version of the often-broken SO_LINGER socket option.  For why
        -: 2058:    ** this is necessary, see http://www.apache.org/docs/misc/fin_wait_2.html
        -: 2059:    ** What we do is delay the actual closing for a few seconds, while reading
        -: 2060:    ** any bytes that come over the connection.  However, we don't want to do
        -: 2061:    ** this unless it's necessary, because it ties up a connection slot and
        -: 2062:    ** file descriptor which means our maximum connection-handling rate
        -: 2063:    ** is lower.  So, elsewhere we set a flag when we detect the few
        -: 2064:    ** circumstances that make a lingering close necessary.  If the flag
        -: 2065:    ** isn't set we do the real close now.
        -: 2066:    */
    #####: 2067:    if ( c->conn_state == CNST_LINGERING )
        -: 2068:	{
        -: 2069:	/* If we were already lingering, shut down for real. */
    #####: 2070:	tmr_cancel( c->linger_timer );
    #####: 2071:	c->linger_timer = (Timer*) 0;
    #####: 2072:	c->hc->should_linger = 0;
        -: 2073:	}
    #####: 2074:    if ( c->hc->should_linger )
        -: 2075:	{
    #####: 2076:	if ( c->conn_state != CNST_PAUSING )
    #####: 2077:	    fdwatch_del_fd( c->hc->conn_fd );
    #####: 2078:	c->conn_state = CNST_LINGERING;
    #####: 2079:	shutdown( c->hc->conn_fd, SHUT_WR );
    #####: 2080:	fdwatch_add_fd( c->hc->conn_fd, c, FDW_READ );
    #####: 2081:	client_data.p = c;
    #####: 2082:	if ( c->linger_timer != (Timer*) 0 )
    #####: 2083:	    syslog( LOG_ERR, "replacing non-null linger_timer!" );
    #####: 2084:	c->linger_timer = tmr_create(
        -: 2085:	    tvP, linger_clear_connection, client_data, LINGER_TIME, 0 );
    #####: 2086:	if ( c->linger_timer == (Timer*) 0 )
        -: 2087:	    {
    #####: 2088:	    syslog( LOG_CRIT, "tmr_create(linger_clear_connection) failed" );
    #####: 2089:	    exit( 1 );
        -: 2090:	    }
        -: 2091:	}
        -: 2092:    else
    #####: 2093:	really_clear_connection( c, tvP );
    #####: 2094:    }
        -: 2095:
        -: 2096:
        -: 2097:static void
    #####: 2098:really_clear_connection( connecttab* c, struct timeval* tvP )
        -: 2099:    {
    #####: 2100:    stats_bytes += c->hc->bytes_sent;
    #####: 2101:    if ( c->conn_state != CNST_PAUSING )
    #####: 2102:	fdwatch_del_fd( c->hc->conn_fd );
    #####: 2103:    httpd_close_conn( c->hc, tvP );
    #####: 2104:    clear_throttles( c, tvP );
    #####: 2105:    if ( c->linger_timer != (Timer*) 0 )
        -: 2106:	{
    #####: 2107:	tmr_cancel( c->linger_timer );
    #####: 2108:	c->linger_timer = 0;
        -: 2109:	}
    #####: 2110:    c->conn_state = CNST_FREE;
    #####: 2111:    c->next_free_connect = first_free_connect;
    #####: 2112:    first_free_connect = c - connects;	/* division by sizeof is implied */
    #####: 2113:    --num_connects;
    #####: 2114:    }
        -: 2115:
        -: 2116:
        -: 2117:static void
    #####: 2118:idle( ClientData client_data, struct timeval* nowP )
        -: 2119:    {
        -: 2120:    int cnum;
        -: 2121:    connecttab* c;
        -: 2122:
    #####: 2123:    for ( cnum = 0; cnum < max_connects; ++cnum )
        -: 2124:	{
    #####: 2125:	c = &connects[cnum];
    #####: 2126:	switch ( c->conn_state )
        -: 2127:	    {
        -: 2128:	    case CNST_READING:
    #####: 2129:	    if ( nowP->tv_sec - c->active_at >= IDLE_READ_TIMELIMIT )
        -: 2130:		{
    #####: 2131:		syslog( LOG_INFO,
        -: 2132:		    "%.80s connection timed out reading",
    #####: 2133:		    httpd_ntoa( &c->hc->client_addr ) );
    #####: 2134:		httpd_send_err(
        -: 2135:		    c->hc, 408, httpd_err408title, "", httpd_err408form, "" );
    #####: 2136:		finish_connection( c, nowP );
        -: 2137:		}
    #####: 2138:	    break;
        -: 2139:	    case CNST_SENDING:
        -: 2140:	    case CNST_PAUSING:
    #####: 2141:	    if ( nowP->tv_sec - c->active_at >= IDLE_SEND_TIMELIMIT )
        -: 2142:		{
    #####: 2143:		syslog( LOG_INFO,
        -: 2144:		    "%.80s connection timed out sending",
    #####: 2145:		    httpd_ntoa( &c->hc->client_addr ) );
    #####: 2146:		clear_connection( c, nowP );
        -: 2147:		}
    #####: 2148:	    break;
        -: 2149:	    }
        -: 2150:	}
    #####: 2151:    }
        -: 2152:
        -: 2153:
        -: 2154:static void
    #####: 2155:wakeup_connection( ClientData client_data, struct timeval* nowP )
        -: 2156:    {
        -: 2157:    connecttab* c;
        -: 2158:
    #####: 2159:    c = (connecttab*) client_data.p;
    #####: 2160:    c->wakeup_timer = (Timer*) 0;
    #####: 2161:    if ( c->conn_state == CNST_PAUSING )
        -: 2162:	{
    #####: 2163:	c->conn_state = CNST_SENDING;
    #####: 2164:	fdwatch_add_fd( c->hc->conn_fd, c, FDW_WRITE );
        -: 2165:	}
    #####: 2166:    }
        -: 2167:
        -: 2168:static void
    #####: 2169:linger_clear_connection( ClientData client_data, struct timeval* nowP )
        -: 2170:    {
        -: 2171:    connecttab* c;
        -: 2172:
    #####: 2173:    c = (connecttab*) client_data.p;
    #####: 2174:    c->linger_timer = (Timer*) 0;
    #####: 2175:    really_clear_connection( c, nowP );
    #####: 2176:    }
        -: 2177:
        -: 2178:
        -: 2179:static void
    #####: 2180:occasional( ClientData client_data, struct timeval* nowP )
        -: 2181:    {
    #####: 2182:    mmc_cleanup( nowP );
    #####: 2183:    tmr_cleanup();
    #####: 2184:    watchdog_flag = 1;		/* let the watchdog know that we are alive */
    #####: 2185:    }
        -: 2186:
        -: 2187:
        -: 2188:#ifdef STATS_TIME
        -: 2189:static void
    #####: 2190:show_stats( ClientData client_data, struct timeval* nowP )
        -: 2191:    {
    #####: 2192:    logstats( nowP );
    #####: 2193:    }
        -: 2194:#endif /* STATS_TIME */
        -: 2195:
        -: 2196:
        -: 2197:/* Generate debugging statistics syslog messages for all packages. */
        -: 2198:static void
    #####: 2199:logstats( struct timeval* nowP )
        -: 2200:    {
        -: 2201:    struct timeval tv;
        -: 2202:    time_t now;
        -: 2203:    long up_secs, stats_secs;
        -: 2204:
    #####: 2205:    if ( nowP == (struct timeval*) 0 )
        -: 2206:	{
    #####: 2207:	(void) gettimeofday( &tv, (struct timezone*) 0 );
    #####: 2208:	nowP = &tv;
        -: 2209:	}
    #####: 2210:    now = nowP->tv_sec;
    #####: 2211:    up_secs = now - start_time;
    #####: 2212:    stats_secs = now - stats_time;
    #####: 2213:    if ( stats_secs == 0 )
    #####: 2214:	stats_secs = 1;	/* fudge */
    #####: 2215:    stats_time = now;
    #####: 2216:    syslog( LOG_NOTICE,
        -: 2217:	"up %ld seconds, stats for %ld seconds:", up_secs, stats_secs );
        -: 2218:
    #####: 2219:    thttpd_logstats( stats_secs );
    #####: 2220:    httpd_logstats( stats_secs );
    #####: 2221:    mmc_logstats( stats_secs );
    #####: 2222:    fdwatch_logstats( stats_secs );
    #####: 2223:    tmr_logstats( stats_secs );
    #####: 2224:    }
        -: 2225:
        -: 2226:
        -: 2227:/* Generate debugging statistics syslog message. */
        -: 2228:static void
    #####: 2229:thttpd_logstats( long secs )
        -: 2230:    {
    #####: 2231:    if ( secs > 0 )
    #####: 2232:	syslog( LOG_NOTICE,
        -: 2233:	    "  thttpd - %ld connections (%g/sec), %d max simultaneous, %lld bytes (%g/sec), %d httpd_conns allocated",
    #####: 2234:	    stats_connections, (float) stats_connections / secs,
        -: 2235:	    stats_simultaneous, (long long) stats_bytes,
    #####: 2236:	    (float) stats_bytes / secs, httpd_conn_count );
    #####: 2237:    stats_connections = 0;
    #####: 2238:    stats_bytes = 0;
    #####: 2239:    stats_simultaneous = 0;
    #####: 2240:    }
